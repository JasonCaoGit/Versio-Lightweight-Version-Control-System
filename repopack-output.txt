This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-07T18:32:05.001Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
1.txt
2.txt
versio-design.md
versio/Blob.java
versio/Branch.java
versio/Commit.java
versio/Dumpable.java
versio/DumpObj.java
versio/FileStored.java
versio/GitletException.java
versio/Head.java
versio/Main.java
versio/Makefile
versio/Repository.java
versio/StagingArea.java
versio/Utils.java
Makefile
README.md
testing/Makefile
testing/runner.py
testing/samples/definitions.inc
testing/samples/test01-init.in
testing/samples/test02-basic-checkout.in
testing/samples/test03-basic-log.in
testing/samples/test04-prev-checkout.in
testing/src/notwug.txt
testing/src/wug.txt
testing/staff-runner.py
testing/student_tests/definitions.inc
testing/tester.py
testing/wug.txt
wug.txt

================================================================
Repository Files
================================================================

================
File: 1.txt
================
<<<<<<< HEAD
unmodified=======
>>>>>>>

================
File: 2.txt
================
add

================
File: versio-design.md
================
# Gitlet Design Document

**Name**:

## Classes and Data Structures

### Main

#### Fields

1. Branch branch
2. Commit  //need name specified
3. 


### Repository
It sets up all functions the main needs to 
execute stuff.

#### Fields

1. Field 1
2. Field 2

### Commit
You find the current commit object
#### Fields
1. Branch
2. isHead


### Head
Creates head object that store String current head and can be stored in Head
folder

#### Fields

1. currentHead


### Branch
Creates a branch object and save it as an serialized object

#### Fields

1. branchName
2. currentCommit

### Stagingarea
We use a hashmap to store the connections between files and blobs,
this class is used to save the map as an object and read them back

#### Fields

1. currentHead
## Algorithms

## Persistence
For all commits, save them as objects within a folder that 
has the two first letter of its UID. Save the blob in that 
folder too!
For staging area, we need a hashmap for a staging area
and we save that hash map as a file, next we commit we use the file

================
File: versio/Blob.java
================
package versio;

import java.io.File;

public class Blob {
    public static void saveBlob(byte[] blob, String blobID) {
        Repository.BLOBS_DIR.mkdir();
        File blobFile = Utils.join(Repository.BLOBS_DIR, blobID);
        Utils.writeObject(blobFile, blob);
    }

    //ReadBlob function is also needed
}

================
File: versio/Branch.java
================
package versio;

import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;

public class Branch implements Serializable {
    private String branchName;
    private String currentCommit;
    private boolean hasHead;





    public void setHasHead(boolean hasHead) {
        this.hasHead = hasHead;
        this.save();
    }


    public static Branch getBranchByName(String branchName) {
        File branchFile = Utils.join(Repository.Branches_DIR, branchName);
        if (branchFile.exists()) {
            Branch branch = convertFileToBranch(branchFile);
            return branch;


        } else {
            System.out.println("The given branch does not exist");
            return null;
        }
    }




    //List all files in the branch path
    public static ArrayList<String> getCurrentBranches() {
        ArrayList<String> branches = Repository.listAllFiles(Repository.Branches_DIR);
        return branches;
    }


    public static boolean isDuplicated(String branchName) {
        ArrayList<String> branches = Repository.listAllFiles(Repository.Branches_DIR);
        for (String branch : branches) {
            if (branch.equals(branchName)) {
                return true;
            }
        }
        return false;

    }


    public static void setNewCommit(String commitID) {
        Branch currentBranch = findCurrentBranch();
        currentBranch.setCurrentCommit(commitID);
        currentBranch.save();


    }








    public Branch(String branchName, String currentCommit, boolean hasHead) {
        this.branchName = branchName;
        this.currentCommit = currentCommit;
        this.hasHead = hasHead;
        save();
    }
    /*
    * Find the branch that has hasHead as true in the branch folder
    * return the string
    *
    * */
    public static Branch findCurrentBranch() {
        ArrayList<String> branches = Repository.listAllFiles(Repository.Branches_DIR);
        for( String branch : branches ) {
            File f = Utils.join(Repository.Branches_DIR, branch);
            Branch b = convertFileToBranch(f);
            if (b.hasHead == true) {
                return b;
            }
        }
        System.out.println("No branch has head");
        return null;

    }


    public static Branch convertFileToBranch(File file) {
        return Utils.readObject(file, Branch.class);
    }

    public void save() {
        Repository.Branches_DIR.mkdir();
        File Branch = Utils.join(Repository.Branches_DIR, getBranchName());
        Utils.writeObject(Branch, this);

    }

    public String getBranchName() {
        return branchName;
    }
    public String getCurrentCommit() {
        return currentCommit;
    }

    public void setCurrentCommit(String currentCommit) {
        this.currentCommit = currentCommit;
    }

    public static void main(String[] args) {
        Branch branch = new Branch("master", "52318edb2df58fa951f9a32a3f78e879e8c0c597", true);

        branch.save();
    }



}

================
File: versio/Commit.java
================
package versio;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.io.File;
import java.util.ArrayList;
// TODO: any imports you need here


/**
 * Represents a versio commit object.
 *  TODO: It's a good idea to give a description here of what else this Class
 *  does at a high level.
 *
 * @author TODO
 */
public class Commit implements Serializable {
    /**
     * TODO: add instance variables here.
     * <p>
     * <p>
     * List all instance variables of the Commit class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided one example for `message`.
     */
    private String timeStamp;
    private ArrayList<String> parentCommit;
    private String branch;//If we have head class, we can ignore this attribute

    private String UID;
    //sth for file name
    private Map<String,String> filesMap;
    private ArrayList<String> secondParent;








    //sth that can link file and blob

    //Read the curren head
    //Get the UID of the current commit
    /*
    * Go to commit path and search for that commit file
    * Return the commit object
    * */


    public static Commit findCurrentCommit() {
        String currentCommitID = Head.readCurrentHead();

        File commitFile = Utils.join(Repository.COMMITS_DIR, currentCommitID);
        Commit currentCommit = Utils.readObject(commitFile, Commit.class);

        return currentCommit;
    }

    public static Commit findCommitByUID(String UID) {
        File commitFile = Utils.join(Repository.COMMITS_DIR, UID);
        if (!commitFile.exists()) {
            return null;
        } else {
            return Utils.readObject(commitFile, Commit.class);
        }
    }






    //Find the current commit using the ID
    //New commit has an empty map that stores no file
    public Commit() {
        this.timeStamp = new Date(0).toString();
        parentCommit = new ArrayList<>();
        this.message = "initial commit";

        Map<String, String> map = new HashMap<>();
        filesMap = new HashMap<String,String>();
        setUID(Utils.sha1(timeStamp, message, parentCommit.toString(), filesMap.toString()));
        Head HEAD = new Head(this.UID);
        System.out.println(Head.readCurrentHead());
        Branch master = new Branch("Master", this.UID, true);
        save();

        //For initial commit we only use these metadata. M

        // May need modification

    }

    public Commit(String message, ArrayList<String> parentCommit, Map<String,String> filesMap) {
        this.timeStamp = new Date().toString();
        this.parentCommit = parentCommit;
        this.filesMap = filesMap;
        this.message = message;
        setUID(Utils.sha1(timeStamp, message, parentCommit.toString(), filesMap.toString()));
        Head.setHead(this.UID);

        Branch.setNewCommit(this.UID);
        save();
    }

    public Commit(String message, ArrayList<String> parentCommit, ArrayList<String> secondParent, Map<String,String> filesMap) {
        this.timeStamp = new Date().toString();
        this.parentCommit = parentCommit;
        this.secondParent = secondParent;
        this.filesMap = filesMap;
        this.message = message;
        setUID(Utils.sha1(timeStamp, message, parentCommit.toString(), filesMap.toString()));
        Head.setHead(this.UID);

        Branch.setNewCommit(this.UID);
        save();
    }


    public void save() {
        Repository.COMMITS_DIR.mkdir();
        File commitFile = Utils.join(Repository.COMMITS_DIR, this.getUID());
        Utils.writeObject(commitFile, this);

    }


    /**
     * The message of this Commit.
     */
    private String message;

    /* TODO: fill in the rest of this class. */

    public String getTimeStamp() {
        return this.timeStamp;
    }

    public ArrayList<String> getParentCommit() {
        return this.parentCommit;
    }

    public String getMessage() {
        return this.message;
    }

    public void setTimeStamp(String timeStamp) {
        this.timeStamp = timeStamp;
    }

    public void setParentCommit(ArrayList<String> parentCommit) {
        this.parentCommit = parentCommit;

    }

    public void setMessage(String message) {
        this.message = message;
    }


//    public String getBranch() {
//        return this.branch;
//
//
//    }

//
//    public void setBranch(String branch) {
//        this.branch = branch;
//    }


    public static void main(String[] args) {
        System.out.println(new Date(0));

        Commit c = new Commit();
        System.out.println(findCurrentCommit().getUID());

    }

    public String getUID() {
        return this.UID;
    }

    public void setUID(String UID) {
        this.UID = UID;
    }

    public Map<String, String> getFilesMap() {
        return this.filesMap;
    }

    public void setFilesMap(Map<String, String> files) {
        this.filesMap = files;
    }
}

================
File: versio/Dumpable.java
================
package versio;

import java.io.Serializable;

/** An interface describing dumpable objects.
 *  @author P. N. Hilfinger
 */
interface Dumpable extends Serializable {
    /** Print useful information about this object on System.out. */
    void dump();
}

================
File: versio/DumpObj.java
================
package versio;

import java.io.File;

/** A debugging class whose main program may be invoked as follows:
 *      java versio.DumpObj FILE...
 *  where each FILE is a file produced by Utils.writeObject (or any file
 *  containing a serialized object).  This will simply read FILE,
 *  deserialize it, and call the dump method on the resulting Object.
 *  The object must implement the versio.Dumpable interface for this
 *  to work.  For example, you might define your class like this:
 *
 *        import java.io.Serializable;
 *        import java.util.TreeMap;
 *        class MyClass implements Serializeable, Dumpable {
 *            ...
 *            @Override
 *            public void dump() {
 *               System.out.printf("size: %d%nmapping: %s%n", _size, _mapping);
 *            }
 *            ...
 *            int _size;
 *            TreeMap<String, String> _mapping = new TreeMap<>();
 *        }
 *
 *  As illustrated, your dump method should print useful information from
 *  objects of your class.
 *  @author P. N. Hilfinger
 */
public class DumpObj {

    /** Deserialize and apply dump to the contents of each of the files
     *  in FILES. */
    public static void main(String... files) {
        for (String fileName : files) {
            Dumpable obj = Utils.readObject(new File(fileName),
                                            Dumpable.class);
            obj.dump();
            System.out.println("---");
        }
    }
}

================
File: versio/FileStored.java
================
package versio;

public class FileStored {
}

================
File: versio/GitletException.java
================
package versio;

/** General exception indicating a Gitlet error.  For fatal errors, the
 *  result of .getMessage() is the error message to be printed.
 *  @author P. N. Hilfinger
 */
class GitletException extends RuntimeException {


    /** A GitletException with no message. */
    GitletException() {
        super();
    }

    /** A GitletException MSG as its message. */
    GitletException(String msg) {
        super(msg);
    }

}

================
File: versio/Head.java
================
package versio;

import java.io.File;
import java.io.Serializable;

public class Head implements Serializable {
    public String currentHead;


    public static void setHead(String commitID) {
        Head head = findCurrentHeadObject();
        head.currentHead = commitID;
        head.save();

    }

    public Head(String currentHead) {
        this.currentHead = currentHead;
        this.save();
    }


    public static Head findCurrentHeadObject() {
        File HEAD = Utils.join(Repository.Head_DIR, "HEAD");
        Head headToRead = Utils.readObject(HEAD, Head.class);
        return headToRead;
    }


    public static String readCurrentHead() {
        File HEAD = Utils.join(Repository.Head_DIR, "HEAD");
        if (HEAD.exists()) {
            Head headToRead = Utils.readObject(HEAD, Head.class);
            return headToRead.currentHead;
        } else {
            System.out.println("There is no head file. Did you initialize the repo?");
            return null;
        }
    }

    public void setCurrentHead(String currentHead) {
        this.currentHead = currentHead;
        this.save();
    }
    //serialize the head object and save it
    public void save() {
        Repository.Head_DIR.mkdir();
        File HEAD = Utils.join(Repository.Head_DIR, "HEAD");
        Utils.writeObject(HEAD, this);

    }

    public static void main(String[] args) {
        Head head = new Head("52318edb2df58fa951f9a32a3f78e879e8c0c597");
        head.save();
        readCurrentHead();
        System.out.println(readCurrentHead());
        System.out.println(readCurrentHead());

    }


}

================
File: versio/Main.java
================
package versio;

/** Driver class for Gitlet, a subset of the Git version-control system.
 *  @author Zhuoyuan Cao
 */
public class Main {

    /** Usage: java versio.Main ARGS, where ARGS contains
     *  <COMMAND> <OPERAND1> <OPERAND2> ... 
     */
    public static void main(String[] args) throws GitletException {
        // TODO: what if args is empty?
        if (args.length < 1) {
            System.out.println("Please enter your command!");
            System.exit(0);

        }
        String firstArg = args[0];
        //Creates a new .versio file in the current directory
        /*
        * Have the initial commit, no files tracked stored in .versio
        * Commit msg = "initial commit"
        * Create a new branch: master, points to the above commit
        * Set the commit metadeta, its time is 1970...
        * And its UID
        * Exits if error occured, A Gitlet version-control system already exists in the current directory
        * */
        switch(firstArg) {
            case "init":
                try {
                    Repository.initRepository();
                } catch (GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }

                // TODO: handle the `init` command
                break;
            case "add":
                // TODO: handle the `add [filename]` command
                //First write the code to add 1 file

                    Repository.add(args[1]);





                break;

            case "commit":
                try {
                       if (args.length == 1) {
                        throw new GitletException("Please enter a commit message");

                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }

                String message = args[1];
                try {
                    Repository.commit(message);
                } catch (GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                break;

            case "rm":
                try {
                       if (args.length == 1) {
                           throw new GitletException("Please enter the file to remove");

                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                String file = args[1];
                try {
                       Repository.rm(file);
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                break;

            case "log":
                Repository.log();
                break;

            case "global-log":
                Repository.logGlobally();
                break;
            case "find":
                try {
                       if (args.length == 1) {
                           throw new GitletException("Please enter the file commit message to find!");

                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }

                String commitMessage = args[1];
                try {
                    Repository.find(commitMessage);
                } catch (GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                break;
            case "branch":
                try {
                    if (args.length == 1) {
                        throw new GitletException("Please enter the branch name");

                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                String branchName = args[1];
                try {
                    Repository.branch(branchName);
                } catch (GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                break;

            case "checkout":
                try {
                    if (args.length == 1) {
                        throw new GitletException("Please enter the branchName or -- file or commitID -- file!");


                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                //You should edit here to prevent user to enter different stuff

                if (args.length == 3 && args[1].equals("--")) {
                    try {
                        String fileName = args[2];
                        Repository.checkoutFile(fileName);
                    } catch (GitletException e) {
                        System.out.println(e.getMessage());
                        System.exit(0);
                    };


                }


                if (args.length == 4 && args[2].equals("--")) {
                    try {
                        String commitID = args[1];
                        String fileName = args[3];
                        Repository.checkoutCommitFile(commitID, fileName);
                    } catch (GitletException e) {
                        System.out.println(e.getMessage());
                        System.exit(0);
                    };


                }


                if (args.length == 2 ) {
                    try {
                        String branchToCheckOut = args[1];
                        Repository.checkoutBranch(branchToCheckOut);
                    } catch (GitletException e) {
                        System.out.println(e.getMessage());
                        System.exit(0);
                    }
                    ;


                }
                break;

            case "status":
                Repository.status();
                break;

            case "rm-branch":
                try {
                    if (args.length == 1) {
                        throw new GitletException("Please enter the branchName!");


                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                try {
                    String branch = args[1];
                Repository.rmBranch(branch);
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                break;


            case "reset":
                try {
                    if (args.length == 1) {
                        throw new GitletException("Please enter the branchName!");


                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                try {
                    String commitID = args[1];
                    Repository.reset(commitID);
                } catch (GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }

                break;
            case "merge":
                try {
                    if (args.length == 1) {
                        throw new GitletException("Please enter the branchName!");


                }
                }catch(GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }
                try {
                    String branchToMerge = args[1];

                    Repository.merge(branchToMerge);
                } catch (GitletException e) {
                    System.out.println(e.getMessage());
                    System.exit(0);
                }















            // TODO: FILL THE REST IN
        }
    }
}

================
File: versio/Makefile
================
# This makefile is defined to give you the following targets:
#
#    default: The default target: Compiles $(PROG) and whatever it 
#	   depends on.
#    check: Compile $(PROG), if needed, and then for each file, F.in, in
#	   directory testing, use F.in as input to "java $(MAIN_CLASS)" and
#          compare the output to the contents of the file names F.out.
#          Report discrepencies.
#    clean: Remove all the .class files produced by java compilation, 
#          all Emacs backup files, and testing output files.
#
# In other words, type 'make' to compile everything; 'make check' to 
# compile and test everything, and 'make clean' to clean things up.
# 
# You can use this file without understanding most of it, of course, but
# I strongly recommend that you try to figure it out, and where you cannot,
# that you ask questions.

JFLAGS = -g -Xlint:unchecked -Xlint:deprecation

CLASSDIR = ../classes

# See comment in ../Makefile
PYTHON = python3

RMAKE = "$(MAKE)"

# A CLASSPATH value that (seems) to work on both Windows and Unix systems.
# To Unix, it looks like ..:$(CLASSPATH):JUNK and to Windows like
# JUNK;..;$(CLASSPATH).

LIB = ../../library-sp21/javalib/*


CPATH = "$(LIB):..:$(CLASSPATH):;$(LIB);..;$(CLASSPATH)"

# All .java files in this directory.
SRCS := $(wildcard *.java)

.PHONY: default check clean

# As a convenience, you can compile a single Java file X.java in this directory
# with 'make X.class'
%.class: %.java
	javac $(JFLAGS) -cp $(CPATH) $<

# First, and therefore default, target.
default: sentinel

check:
	$(RMAKE) -C .. PYTHON=$(PYTHON) check

integration:
	$(RMAKE) -C .. PYTHON=$(PYTHON) integration

# 'make clean' will clean up stuff you can reconstruct.
clean:
	$(RM) *~ *.class sentinel

### DEPENDENCIES ###

sentinel: $(SRCS)
	javac $(JFLAGS) -cp $(CPATH) $(SRCS)
	touch sentinel

================
File: versio/Repository.java
================
package versio;

import java.io.File;
import static versio.Utils.*;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

// TODO: any imports you need here

/**
 * Represents a versio repository.
 *  TODO: It's a good idea to give a description here of what else this Class
 *  does at a high level.
 *
 * @author Zhuoyuan Cao
 */
public class Repository {
    /**
     * TODO: add instance variables here.
     *
     * List all instance variables of the Repository class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided two examples for you.
     */

    /**
     * The current working directory.
     */


    public static void main(String[] args) {

            merge("Master");
        status();
        Commit commit = Commit.findCurrentCommit();
        System.out.println(commit.getFilesMap());
        merge("Master");
        ArrayList<String> list = new ArrayList<>();

        list.add("e");
        list.add("c");
        list.add("a");
        list.add("e");
        list.add("a");
        list.add("b");
        list.add("g");
        list.add("d");
        list.add("b");

        ArrayList<String> sorted = mergeSort(list);
        System.out.println(sorted.toString());

//        Head head = Head.findCurrentHeadObject();
//        System.out.println(head.currentHead);
//        System.out.println(head.currentHead);
//        Branch branch = Branch.findCurrentBranch();
//        System.out.println(branch.getCurrentCommit());
//        System.out.println(branch.getBranchName());
//
//
//
//
//
//        Map<String, String> stagingArea = StagingArea.readStagingArea();
//        System.out.println(stagingArea);


        //first manual commit
        //;


    }


    public static final File CWD = new File(System.getProperty("user.dir"));
    /**
     * The .versio directory.
     */
    public static final File GITLET_DIR = join(CWD, ".versio");
    public static final File COMMITS_DIR = join(GITLET_DIR, "Commits");
    public static final File BLOBS_DIR = join(GITLET_DIR, "Blobs");
    public static final File STAGING_AREA = join(GITLET_DIR, "StagingArea");
    public static final File Head_DIR = join(GITLET_DIR, "HEAD");
    public static final File Branches_DIR = join(GITLET_DIR, "Branches");


    public static String readByteObjectAsString(File blobToRead) {
        byte[] byteObject = Utils.readObject(blobToRead, byte[].class);
        return new String(byteObject, StandardCharsets.UTF_8);
    }




    /*
    * Merge files in the given branch to the current
    * The split point is the earliest common parent commits of two commits
    * Several scenarios regarding the split point
    * 1 if the split point is the same commit as the given branch
    * do nothing. Display  Given branch is an ancestor of the current branch.
    * 2 if the split point is the current branch
    * then we checkout the given branch and displays Current branch fast-forwarded
    *
    * If not the scenatrios above do the following
    *1 If a  file that is modified btween given branch and the split point
    * but is not modified in the current branch, change it to the version in the given branch
    * The files will be staged(overwrite and stage)
    *
    * 2 if a file that is modified in the current branch but not in the given branch
    * stay the same
    * 3 If a file is modified in the same way, same content or both removed,
    * are left unchanged. If a file was removed from both, and it is still in the CWD
    * do not track it or stage it
    * 4 If a file is not in the split point and the given branch
    *  but is in the current branch only, remain the same
    * 5 If a file not in the split point and the current branch
    * , only in the given branch, checkout that file and stage it
    * 6 If a file is in the split point, unchanged in the current branch, and not in the given branch
    * remove it and do not track it in the merge commit
    * 7 If a file is at the split point, unchanged in  the given branch, and not in the current branch,
    * it will not be tracked in the merge commit
    * 8 Any files that are modified differently are in conflict
    *They could be modified differently or one is changed and another is delteld
    * If a conflict happens replace the conflict file to this:
    * <<<<<<< HEAD
contents of file in current branch
=======
contents of file in given branch
>>>>>>>
* fill blank if it is deleted in one branch
* and stage this file to addition.
*
*
* Once already commit automatically with the commit message Merged [given branch name] into
[current branch name].
* Print  Encountered a
merge conflict, if encounter a conflict
* Merged commits have the current branch as the first parent
* and the given branch as the second parent
*
*
*
*
* Exceptions:
* 1 if staging area has files , error You have
uncommitted changes.
* 2 If the branch does not exist, A branch with that name does not exist.
    *

3    if the branch is the current branch, error  Cannot merge a branch with itself
*
* 4 if the merge commit will overwrite a untracked file, error   There is an untracked file in the way; delete it, or add and commit it
first.
    *
     */

    public static void merge(String branchName) throws GitletException {
        Map<String, String> stagingArea = StagingArea.readStagingArea();
        if (stagingArea.size() > 0) {
            throw new GitletException(" You have uncommitted changes.");
        }
        boolean doesExist = Branch.isDuplicated(branchName);
        if (!doesExist) {
            throw new GitletException("A branch with that name does not exist.");



        }

        Branch currentBranch = Branch.findCurrentBranch();
        if(currentBranch.getBranchName().equals(branchName)) {
            throw new GitletException("Not supposed to merge a branch with itself");
        }

/*
         Merge files in the given branch to the current
    * The split point is the earliest common parent commits of two commits
    * Several scenarios regarding the split point
    * 1 if the split point is the same commit as the given branch
    * do nothing. Display  Given branch is an ancestor of the current branch.
    * 2 if the split point is the current branch
    * then we checkout the given branch and displays Current branch fast-forwarded
    **/
        /*
        * We have to find the split point of two branch commits.
        * */

        //first we reverse two lists of ancestors, these two lists must have some common ancesstors, and they must have the same index after the list is reversed
        String currentBranchCommitID = currentBranch.getCurrentCommit();
        Commit currentBranchCommit = Commit.findCommitByUID(currentBranchCommitID);
        Branch givenBranch = Branch.getBranchByName(branchName);
        Commit givenBranchCommit = Commit.findCommitByUID(givenBranch.getCurrentCommit());
        //now we have the two branch commits, get their ancestor list
        ArrayList<String> currentAncestorList = currentBranchCommit.getParentCommit();
        currentAncestorList.add(currentBranchCommitID);
        ArrayList<String> givenAncestorList = givenBranchCommit.getParentCommit();
        givenAncestorList.add(givenBranch.getCurrentCommit());

        //find the right list to iterate
        ArrayList<String> listToIterate = null;
        ArrayList<String> listToCompare = null;
        if (currentAncestorList.size() < givenAncestorList.size()) {
            listToIterate = currentAncestorList;
            listToCompare = givenAncestorList;
        } else {
            listToIterate = givenAncestorList;
            listToCompare = currentAncestorList;
        }
        int theFirstAncestorNotEqual = -1;
        //Iterate the list of ancestors and find the leftmost ancestor that is not the same
        for (int i =0 ; i < listToIterate.size(); i++) {
            if(!listToIterate.get(i).equals(listToCompare.get(i))) {
                theFirstAncestorNotEqual = i;
                break;
            }

        }
        if(theFirstAncestorNotEqual == -1) {
            theFirstAncestorNotEqual = listToIterate.size();
        }
        String splitPoint = listToIterate.get(theFirstAncestorNotEqual - 1);
        System.out.println(splitPoint);
        // now we can find the split point





//            * Merge files in the given branch to the current
//    * The split point is the earliest common parent commits of two commits
//    * Several scenarios regarding the split point
//    * 1 if the split point is the same commit as the given branch
//    * do nothing. Display  Given branch is an ancestor of the current branch.
//    * 2 if the split point is the current branch
//    * then we checkout the given branch and displays Current branch fast-forwarded
//    *
    System.out.println(givenBranch.getCurrentCommit());
        if(splitPoint.equals(givenBranch.getCurrentCommit())) {

            System.out.println("Given branch is an ancestor of the current branch.");
        }
        if (splitPoint.equals(currentBranchCommit.getUID())) {
            checkoutBranch(givenBranch.getBranchName());
            System.out.println("Current branch fast-forwarded");
        }

/*            * If not the scenarios above do the following
    *1 If a  file that is modified btween given branch and the split point
    * but is not modified in the current branch, change it to the version in the given branch
    * The files will be staged(overwrite and stage)
    *
    * 2 if a file that is modified in the current branch but not in the given branch
    * stay the same
    * 3 If a file is modified in the same way, same content or both removed,
    * are left unchanged. If a file was removed from both, and it is still in the CWD
    * do not track it or stage it*/
        //If a file's blob is different between given branch and split point, same between current branch and ...,
        /*
        * Checkout that file in the given branch, stage the file
        * */
        //Have to find all files in all three commits
        Map<String, String> filesInSplitPoint = Commit.findCommitByUID(splitPoint).getFilesMap();
        Map<String, String> filesInCurrentBranch = currentBranchCommit.getFilesMap();
        Map<String, String> filesInGivenBranch = givenBranchCommit.getFilesMap();
        ArrayList<String> filesToIterate = new ArrayList<>();
        for(String file: filesInSplitPoint.keySet()) {
            filesToIterate.add(file);
        }

        //For everything in current branch commit map
        for(String file: filesInCurrentBranch.keySet()) {
            //if my list does not includ that file name
            if (!filesToIterate.contains(file)) {
                filesToIterate.add(file);
            }
        }

        for(String file: filesInGivenBranch.keySet()) {
            if (!filesToIterate.contains(file)) {
                filesToIterate.add(file);
            }
        }

//        *1 If a  file that is modified between given branch and the split point
//    * but is not modified in the current branch, change it to the version in the given branch
//    * The files will be staged(overwrite and stage)
//    *

        //Iterate through all the files in the three commits
        for(String file: filesToIterate) {
            String currentBranchBlob = filesInCurrentBranch.get(file);
            String givenBranchBlob = filesInGivenBranch.get(file);
            String splitPointBlob = filesInSplitPoint.get(file);
            //First case
            if(currentBranchBlob!= null && givenBranchBlob!= null && splitPointBlob != null) {
                if(!splitPointBlob.equals(givenBranchBlob) && splitPointBlob.equals(currentBranchBlob)) {
                //checkout the file in the given branch and add it
                checkoutFile(givenBranchCommit.getUID(), file);
                add(file);
            }
                 if(!splitPointBlob.equals(currentBranchBlob) && splitPointBlob.equals(givenBranchBlob)) {
                continue;
            }

            }

   /*           * 2 if a file that is modified in the current branch but not in the given branch
    * stay the same*/

//            * 3 If a file is modified in the same way, same content or both removed,
//    * are left unchanged. If a file was removed from both, and it is still in the CWD
//    * do not track it or stage it*/
            //if it is not contained in both
            boolean isRemovedInBoth = false;
            if (splitPointBlob != null) {
                  if(currentBranchBlob == null && givenBranchBlob == null) {
                isRemovedInBoth = true;
            }
            }



            ArrayList<String> CWDFiles = listAllFiles(CWD);
            if (currentBranchBlob != null) {
                   if(currentBranchBlob.equals(givenBranchBlob) || isRemovedInBoth)  {

                if (CWDFiles.contains(file)) {
                    if(stagingArea.containsKey(file)) {
                        stagingArea.remove(file);
                    StagingArea.saveStagingArea(stagingArea);

                    }

                }
            }
            }


//                * 4 If a file is not in the split point and the given branch
//    *  but is in the current branch only, remain the same
            if(splitPointBlob==null && givenBranchBlob == null &&currentBranchBlob != null) {
                continue;
            }
//
//               * 5 If a file not in the split point and the current branch
//    * , only in the given branch, checkout that file and stage it
            if(splitPointBlob==null && currentBranchBlob == null && givenBranchBlob != null) {
                checkoutFile(givenBranchCommit.getUID(), file);
                stagingArea.put(file, givenBranchCommit.getFilesMap().get(file));
                StagingArea.saveStagingArea(stagingArea);
            }










//    * 6 If a file is in the split point, unchanged in the current branch, and not in the given branch
//    * remove it and do not track it in the merge commit
            if (splitPointBlob != null && currentBranchBlob.equals(splitPointBlob) && givenBranchBlob == null) {
                if(stagingArea.containsKey(file)) {
                    stagingArea.remove(file);
                    StagingArea.saveStagingArea(stagingArea);
                }

                if(CWDFiles.contains(file)) {
                    File fileToDelete = Utils.join(CWD, file);
                    Utils.restrictedDelete(fileToDelete);

                }
            }

//    * 7 If a file is at the split point, unchanged in  the given branch, and not in the current branch,
//    * it will not be tracked in the merge commit
            if (givenBranchBlob != null) {
                 if (splitPointBlob!= null && givenBranchBlob.equals(splitPointBlob) && currentBranchBlob == null) {
                if(stagingArea.containsKey(file)) {
                    stagingArea.remove(file);
                    StagingArea.saveStagingArea(stagingArea);
                }
            }
            }


//    * 8 Any files that are modified differently are in conflict
//    *They could be modified differently or one is changed and another is delteld
//               * If a conflict happens replace the conflict file to this:
//    * <<<<<<< HEAD
//contents of file in current branch
//=======
//contents of file in given branch
//>>>>>>>
//* fill blank if it is deleted in one branch
//* and stage this file to addition.

            //determine if both modified in a different way
            boolean mergeConflict = false;
            //if two branches all contain the files and they are not equal to each other
            if(currentBranchBlob != null && givenBranchBlob != null) {
                if(!currentBranchBlob.equals(givenBranchBlob)) {
                    mergeConflict = true;
                }

            }
            //if is deleted in one branch and changed in another
            //if split point has the file
            if (splitPointBlob != null) {
                //also given branch has the file and changed the content
                if (givenBranchBlob != null) {
                    //current branch delete the file
                       if(currentBranchBlob == null && !splitPoint.equals(givenBranchBlob)) {
                           mergeConflict = true;

                }
                }

                //vice versa for the opposite
                 if (currentBranchBlob != null) {
                    //current branch delete the file
                       if(givenBranchBlob == null && !splitPoint.equals(currentBranchBlob)) {
                           mergeConflict = true;

                }
                }



            }
            //tested
            if(mergeConflict) {
                String conflictContent = "<<<<<<< HEAD" + "\n";
                if (currentBranchBlob != null) {
                    File currentFileContent = Utils.join(BLOBS_DIR, currentBranchBlob);
                    //Write the content into a file first and do it
                    conflictContent += readByteObjectAsString(currentFileContent);

                } else {
                    conflictContent += "";
                }
                conflictContent += "=======" + "\n";
                if (givenBranchBlob != null) {
                    File givenFileContent = Utils.join(BLOBS_DIR, givenBranchBlob);

                    conflictContent += readByteObjectAsString(givenFileContent);
                } else {
                    conflictContent += "";
                }
                conflictContent += ">>>>>>>";

                 File fileInCWD = Utils.join(CWD, file);
            if (fileInCWD.exists()) {
                Utils.restrictedDelete(fileInCWD);
            }
            Utils.writeContents(fileInCWD, conflictContent);

                add(file);

            }

            mergeCommit("Merged " + givenBranch.getBranchName() + " into " + currentBranch.getBranchName(), givenBranchCommit.getUID());
            if (mergeConflict) {
                System.out.println("Encountered a merge conflict.");
            }









            //tested ok




        }







    }
















    /*
     * Get all blobs from the given commit,
     * Remove all files that are in the current commit but is not in that commit
     * Move the current branch to that commit
     * Move the current head to that commit
     * Staging area is cleared
     *
     * Exception:
     * If no commit with that ID exists error  No commit with that id exists.
     *2 if a CWD file is untracked and would be overwritten by that given commit,
     * error There is
an untracked file in the way; delete it, or add and commit it first.
     * */

    public static void reset(String commitID) throws GitletException {

        Commit commitToReset = Commit.findCommitByUID(commitID);
        if (commitToReset == null) {
            throw new GitletException("No commit with that id exists.");
        }




//        Branch branchOfInterest = Branch.getBranchByName(branchToCheckout);
//        Commit branchCommit = Commit.findCommitByUID(branchOfInterest.getCurrentCommit());
        System.out.println(commitToReset);
        Map<String, String> commitToResetFilesMap = commitToReset.getFilesMap();
        //delte all the files that are in current commit
        Commit currentCommit = Commit.findCurrentCommit();
        for (String file : currentCommit.getFilesMap().keySet()) {
            File filesTrackInCurrentCommit = Utils.join(CWD, file);
            Utils.restrictedDelete(filesTrackInCurrentCommit);
        }

        //Get all untracked file names
        ArrayList<String> untrackedFiles = findUntrackedFiles();
        //Check if for each file the branch commit has them already
        for (String untracked : untrackedFiles) {
            if (commitToReset.getFilesMap().containsKey(untracked)) {
                //If it has them compare their blobid, if not the same, error. It means the untracked file will be rewritten
                String blobIDInBranch = commitToResetFilesMap.get(untracked);
                File untrackedFile = Utils.join(CWD, untracked);
                if (!compareFileContentByBlob(untrackedFile, blobIDInBranch)) {
                    throw new GitletException("There is an untracked file in the way; delete it, or add and commit it first");

                }
            }
        }
        //Got the commit file map in the branch commit, now iterate through all files
        for (String file : commitToResetFilesMap.keySet()) {


            checkoutCommitFile(commitToReset.getUID(), file);

        }

//        Move the current branch to that commit
//     * Move the current head to that commit
//     * Staging area is cleared

        Branch currentBranch = Branch.findCurrentBranch();
        //current branch points to that commit
        currentBranch.setCurrentCommit(commitID);
        Head.setHead(commitID);
        Map<String, String> stagingArea = new HashMap<>();
        StagingArea.saveStagingArea(stagingArea);
    }


    /*
     * Deletes the branch with the given name
     *
     * Exceptions:
     * If the name does not exist, error   A
branch with that name does not exist
*
* 2 if the branch is the current branch, error Cannot remove the current branch.
     * */
    public static void rmBranch(String branch) throws GitletException {
        Branch branchToRemove = Branch.getBranchByName(branch);
        if (branchToRemove == null) {
            throw new GitletException("A branch with that name does not exist");
        }
        Branch currentBranch = Branch.findCurrentBranch();
        if (currentBranch.getBranchName().equals(branch)) {
            throw new GitletException("Not supposed to remove the current branch.");
        }

        File filesTrackInCurrentCommit = Utils.join(Branches_DIR, branch);
        if (filesTrackInCurrentCommit.delete()) {
            System.out.println("Deleted");

        }
    }


    public static boolean compareFileContentByBlob(File fileToCompare, String blobID) {
        String blobIDToCompare = makeBlobWithoutSaving(fileToCompare);
        return blobIDToCompare.equals(blobID);

    }


    /*
    * Takes all blobs from a commit at the head of the given branch
    * Update the files in CWD
    * Given branch is now the new head branch,
    * means the hasHead of the current branch is set to false
    * and the given branch hashead is set to true
    * the head is also set to the branch commit
    * Any file tracked in the current branch will be deleted
    * if it not in the checkedout branch commit
    *
    * Exceptions:
    * 1 if no branch with that name exists error   No such branch exists.
    * 2 is the given branch is the same as the current branch, error No need to checkout the current branch
    * 3 if a file is untracked and will be overwritten by the check out error There is an untracked file
    in the way; delete it, or add and commit it first. Untracked means it is not staged for addition or is in the current commit
    *
    * Do this to every file in the branch commit
    * Get a blob id, update the files in CWD(check the error condition before)
    * Set the given branch to has head
    * Set the current branch to not has head
    * Set the head value to the given branch commit
    *
    *
    *
    *
    * */
    public static void checkoutBranch(String branchToCheckout) throws GitletException {
        ArrayList<String> branches = Branch.getCurrentBranches();
        boolean branchFound = false;
        for (String branch : branches) {
            if (branch.equals(branchToCheckout)) {
                branchFound = true;
            }
        }
        if (branchFound == false) {
            throw new GitletException("No such branch exists.");
        }

        //if the current branch equals the branch to check out
        Branch currentBranch = Branch.findCurrentBranch();

        if (currentBranch.getBranchName().equals(branchToCheckout)) {
            System.out.println(currentBranch.getBranchName());
            System.out.println(branchToCheckout);
            ;
            throw new GitletException("No need to checkout the current branch");
        }


        /*        * Do this to every file in the branch commit
         * Get a blob id, update the files in CWD(check the error condition before)
         * Set the given branch to has head
         * Set the current branch to not has head
         * Set the head value to the given branch commit*/
        /*
        * if a file is untracked and will be overwritten by the check out error There is an untracked file
in the way; delete it, or add and commit it first. Untracked means it is not staged for addition or is in the current commit
        *
        * */
        Branch branchOfInterest = Branch.getBranchByName(branchToCheckout);
        Commit branchCommit = Commit.findCommitByUID(branchOfInterest.getCurrentCommit());
        System.out.println(branchCommit);
        Map<String, String> branchCommitFileMap = branchCommit.getFilesMap();
        //delte all the files that are in current commit
        Commit currentCommit = Commit.findCurrentCommit();
        for (String file : currentCommit.getFilesMap().keySet()) {
            File filesTrackInCurrentCommit = Utils.join(CWD, file);
            Utils.restrictedDelete(filesTrackInCurrentCommit);
        }

        //Get all untracked file names
        ArrayList<String> untrackedFiles = findUntrackedFiles();
        //Check if for each file the branch commit has them already
        for (String untracked : untrackedFiles) {
            if (branchCommit.getFilesMap().containsKey(untracked)) {
                //If it has them compare their blobid, if not the same, error. It means the untracked file will be rewritten
                String blobIDInBranch = branchCommitFileMap.get(untracked);
                File untrackedFile = Utils.join(CWD, untracked);
                if (!compareFileContentByBlob(untrackedFile, blobIDInBranch)) {
                    throw new GitletException("There is an untracked file in the way; delete it, or add and commit it first");

                }
            }
        }
        //Got the commit file map in the branch commit, now iterate through all files
        for (String file : branchCommitFileMap.keySet()) {


            checkoutCommitFile(branchCommit.getUID(), file);

        }

//        Set the given branch to has head
//* Set the current branch to not has head
//* Set the head value to the given branch commit*/
        branchOfInterest.setHasHead(true);
        currentBranch.setHasHead(false);
        System.out.println(branchCommit.getUID());
        Head.setHead(branchCommit.getUID());
        Commit newCurrentCommit = Commit.findCurrentCommit();
        System.out.println(newCurrentCommit.getUID());


    }


    /*
     * Rewrite the file to the version of the given commit
     *
     * Exception:
     * 1 if the commit does not exists error No Commit with that id exists
     *
     *
     * */
    public static void checkoutCommitFile(String commitID, String fileToCheckout) {
        Commit commitToCheckout = Commit.findCommitByUID(commitID);
        if (commitToCheckout == null) {
            System.out.println("No Commit with that id exists");
            System.exit(0);
        }
        checkoutFile(commitID, fileToCheckout);


    }


    /*Take the blob of all the given file from the current commit
    and rewrite the file in the CWD if it exists
    if not, then add that file and write the blob
    the file is not staged

    Exceptions:
    if the file does not exist in the commit
    error File does not exist in that commit.
    *
    The content of any file is byte[] and the byte[] object is stored in files, read the file and write the byte[] back to the file
    * */
    public static void checkoutFile(String fileToCheckout) throws GitletException {
        Commit currentCommit = Commit.findCurrentCommit();
        String blobIDInCommit = null;
        boolean found = false;
        for (String fileInCommit : currentCommit.getFilesMap().keySet()) {
            if (fileInCommit.equals(fileToCheckout)) {
                blobIDInCommit = currentCommit.getFilesMap().get(fileToCheckout);
                System.out.println("searching");
                found = true;
            }
        }
        if (found == false) {

            throw new GitletException("File does not exist in that commit.");
        }
        //Set the file you wanna rewrite
        File fileInCWD = Utils.join(CWD, fileToCheckout);
        if (fileInCWD.exists()) {
            Utils.restrictedDelete(fileInCWD);
        }


        //if we found the blob id in the current commit, read that blob and write it to the file
        if (blobIDInCommit != null) {
            File blobInCommit = Utils.join(BLOBS_DIR, blobIDInCommit);
            byte[] blobToOverwrite = Utils.readObject(blobInCommit, byte[].class);
            Utils.writeContents(fileInCWD, blobToOverwrite);

        }


    }


    public static void checkoutFile(String commitID, String fileToCheckout) throws GitletException {
        Commit currentCommit = Commit.findCommitByUID(commitID);
        String blobIDInCommit = null;
        boolean found = false;
        for (String fileInCommit : currentCommit.getFilesMap().keySet()) {
            if (fileInCommit.equals(fileToCheckout)) {
                blobIDInCommit = currentCommit.getFilesMap().get(fileToCheckout);
                System.out.println("searching");
                found = true;
            }
        }
        if (found == false) {

            throw new GitletException("File does not exist in that commit.");
        }
        //Set the file you wanna rewrite
        File fileInCWD = Utils.join(CWD, fileToCheckout);
        if (fileInCWD.exists()) {
            Utils.restrictedDelete(fileInCWD);
        }


        //if we found the blob id in the current commit, read that blob and write it to the file
        if (blobIDInCommit != null) {
            File blobInCommit = Utils.join(BLOBS_DIR, blobIDInCommit);
            byte[] blobToOverwrite = Utils.readObject(blobInCommit, byte[].class);
            Utils.writeContents(fileInCWD, blobToOverwrite);

        }


    }










    /* * Display all the modified but not staged file







     * In parenthesis write deleted if a file is staged for addtion
     * but is not found in the working dir
     * OR
     * if a file is in the current commit's fileMap but is deleted in the working dir
     * and it is not in the staging area with 'rm'
     *
     * In parenthesis write modified if a file is in the current commit's fileMap
     * and has different blob than the current commit, and the file is not in the staging area
     * OR
     * a file is in the staging area, but the blob in the staging area is different than what is in the WD
     *
     * Above is for the modified but not staged
     *
     *
     * Several kinds of files
     * Deleted;
     * 1 if a file is staged for addition but is not found in working directory
     * 2 if a file is in the current commit's fileMap but is not in the working directory and not staged for removal
     *
     * Modified:
     * 1 if a file is tracked by the current commit, but the file in cwd has a different blob than the commit's
     * and is not in the staging area
     * 2 if a file is staged for addition but the file in CWD has different blob in the staging area
     * */

    public static void displayModifiedNotStaged() {
        System.out.println("=== Modifications Not Staged For Commit ===");
        //Group all modified files together
        ArrayList<String> modified = new ArrayList<>();
        Map<String, String> stagingArea = StagingArea.readStagingArea();
        Commit currentCommit = Commit.findCurrentCommit();
        //iterate through all the files that are staged for addtion
        for (String fileInStagingArea : stagingArea.keySet()) {
            //if the file is not staged for removal
            if (!stagingArea.get(fileInStagingArea).equals("rm")) {
                //Find the file in CWD
                File fileInCWD = Utils.join(CWD, fileInStagingArea);
                String blobIDCWD = makeBlobWithoutSaving(fileInCWD);

                if (!blobIDCWD.equals(stagingArea.get(fileInStagingArea))) {
                    modified.add(fileInStagingArea);
                }


            }
        }


        //iterate through all the files in current commit


        for (String fileInCommit : currentCommit.getFilesMap().keySet()) {
            File fileInCWD = Utils.join(CWD, fileInCommit);
            //if the file exists in the cwd
            if (fileInCWD.exists()) {
                //compare the blob ids
                String CWDBlobID = makeBlobWithoutSaving(fileInCWD);
                String commitBlobID = currentCommit.getFilesMap().get(fileInCommit);
                if (!commitBlobID.equals(CWDBlobID)) {
                    //check if it is in the staging area
                    if (!stagingArea.containsKey(fileInCommit)) {
                        modified.add(fileInCommit);
                    }

                }
            }
        }


        modified = mergeSort(modified);
        for (String file : modified) {
            System.out.println(file + " (modified)");
        }


        //Group all deleted files together
        ArrayList<String> deletedFiles = new ArrayList<>();
        ArrayList<String> CWDFiles = listAllFiles(CWD);

        //a file is not staged for removal, is in the current commit, not in the current dir

        //Iterate through all the files in current commit
        for (String file : currentCommit.getFilesMap().keySet()) {
            File fileInCWD = Utils.join(CWD, file);


            //if we found a file that is not the directory
            if (!fileInCWD.exists()) {

                //check if the file is staged for removal
                //if it is contained, then its value equals rm?
                //not contained add it to delete
                if (stagingArea.containsKey(file)) {

                    if (!stagingArea.get(file).equals("rm")) {
                        deletedFiles.add(file);

                    }

                } else {
                    deletedFiles.add(file);
                }

            }
        }


        //first I check for the first kind of files
        for (String file : stagingArea.keySet()) {
            //check if it is staged for addtion
            if (!stagingArea.get(file).equals("rm")) {
                //check if the file is in the CWD

                File fileToCheck = Utils.join(CWD, file);
                if (!fileToCheck.exists()) {
                    deletedFiles.add(file);
                }

            }
        }
        //Edited // needs testing
        deletedFiles = mergeSort(deletedFiles);


        for (String file : deletedFiles) {
            System.out.println(file + " (deleted)");
        }
        System.out.println();


    }


    public static void displayStagingArea() {
        System.out.println("=== Staged Files ===");

        Map<String, String> stagingArea = StagingArea.readStagingArea();
        ArrayList<String> addition = new ArrayList<>();
        ArrayList<String> removal = new ArrayList<>();
        for (String key : stagingArea.keySet()) {
            if (stagingArea.get(key).equals("rm")) {
                removal.add(key);
            } else {
                addition.add(key);
            }
        }
        removal = mergeSort(removal);
        addition = mergeSort(addition);
        for (String key : addition) {
            System.out.println(key);
        }
        System.out.println();

        System.out.println("=== Removed Files ===");
        for (String key : removal) {
            System.out.println(key);
        }
        System.out.println();
    }


    public static ArrayList<String> mergeH(ArrayList<String> list1, ArrayList<String> list2) {
        ArrayList<String> merged = new ArrayList<>();
        int i = 0;
        int j = 0;
        while (i < list1.size() && j < list2.size()) {
            if (list1.get(i).compareTo(list2.get(j)) < 0) {
                merged.add(list1.get(i));
                i++;
            } else {
                merged.add(list2.get(j));
                j++;
            }
        }

        while (i < list1.size()) {
            merged.add(list1.get(i));
            i++;
        }

        while (j < list2.size()) {
            merged.add(list2.get(j));
            j++;
        }
        return merged;
    }


    public static ArrayList<String> mergeSort(ArrayList<String> list) {
        if (list.size() < 2) {
            return list;
        } else {
            int n = list.size() / 2;
            ArrayList<String> leftHalf = new ArrayList<>(list.subList(0, n));
            ArrayList<String> rightHalf = new ArrayList<>(list.subList(n, list.size()));
            return mergeH(mergeSort(leftHalf), mergeSort(rightHalf));


        }
    }


    public static void displayCurrentBranches(ArrayList<String> branches) {
        ArrayList<String> sortedBranches = mergeSort(branches);
        System.out.println("=== Branches ===");
        for (String branch : sortedBranches) {
            if (branch.equals(Branch.findCurrentBranch().getBranchName())) {
                System.out.println("*" + branch);
            } else {
                System.out.println(branch);
            }
        }
        System.out.println();
    }


    public static ArrayList<String> findUntrackedFiles() {

        ArrayList<String> untrackedFiles = new ArrayList<>();
        // Iterate through all files in CWD
        ArrayList<String> CWDFiles = listAllFiles(CWD);
        Map<String, String> stagingArea = StagingArea.readStagingArea();
        Commit currentCommit = Commit.findCurrentCommit();
        for (String file : CWDFiles) {
            //if the staging area contains the file and the value is not rm
            //or say if it is staged for addtion, break
            if (stagingArea.containsKey(file)) {
                if (!stagingArea.get(file).equals("rm")) {
                    continue;

                } else {
                    untrackedFiles.add(file);
                }
            }
            //if the commit does not track the file
            if (currentCommit.getFilesMap().containsKey(file)) {
                continue;
            }
            untrackedFiles.add(file);

        }

        return untrackedFiles;

    }


    /*
     * Display all files that are not staged for addtion or tracked in the current commit
     * Besides, includes any file that is staged for removal but still in the directory
     * */
    public static void displayUntracked() {
        System.out.println("=== Untracked Files ===");
        ArrayList<String> untrackedFiles = new ArrayList<>();
        // Iterate through all files in CWD
        ArrayList<String> CWDFiles = listAllFiles(CWD);

        Map<String, String> stagingArea = StagingArea.readStagingArea();
        Commit currentCommit = Commit.findCurrentCommit();

        for (String file : CWDFiles) {
            //if the staging area contains the file and the value is not rm
            //or say if it is staged for addtion, break
            if (stagingArea.containsKey(file)) {
                if (!stagingArea.get(file).equals("rm")) {
                    continue;

                } else {
                    untrackedFiles.add(file);
                }
            }
            //if the commit does not track the file
            if (currentCommit.getFilesMap().containsKey(file)) {
                continue;
            }

            untrackedFiles.add(file);

        }

        untrackedFiles = mergeSort(untrackedFiles);
        for (String file : untrackedFiles) {
            System.out.println(file);
        }
        System.out.println();


    }




    /*
     * Display what branches there is
     * The current branch will have an asterick if it has head
     * display all the file in the staging area
     * Must be displayed in lexicographic order
     *
     * Addtional stuff
     * Display all the modified but not staged file
     * In parenthesis write deleted if a file is staged for addtion
     * but is not found in the working dir
     * OR
     * if a file is in the current commit's fileMap but is deleted in the working dir
     * and it is not in the staging area with 'rm'
     *
     * In parenthesis write modified if a file is in the current commit's fileMap
     * and has different blob than the current commit, and the file is not in the staging area
     * OR
     * a file is in the staging area, but the blob in the staging area is different than what is in the WD
     *
     * Above is for the modified but not staged
     *
     * Display untracked files
     * A file is untracked if it is in the WD, but it is not in the staging area or the current commit
     * Also include the files that have 'rm' in the staging area, but it
     *
     *
     *Display the current branches
     *Display all the files in the staging area
     *
     * */

    public static void status() {

        ArrayList<String> branches = Branch.getCurrentBranches();
        displayCurrentBranches(branches);
        displayStagingArea();
        displayModifiedNotStaged();
        displayUntracked();

    }


    /*
    * Creates a new branch object and save it
    * It will point at the current commit and does not have head for now
    *
    *
    *Exception: If there is already a branch with this name error A branch
with that name already exists.
*
*
    * */
    public static void branch(String branchName) throws GitletException {
        if (Branch.isDuplicated(branchName)) {
            throw new GitletException("A branch with that name already exists.");
        }
        Commit currentCommit = Commit.findCurrentCommit();
        Branch newBranch = new Branch(branchName, currentCommit.getUID(), false);
        //Now we have two branches

    }


    /*
     * Prints out the ids of all commits that have the message
     *
     *
     *
     * */
    public static void find(String message) throws GitletException {
        ArrayList<String> commitFiles = listAllFiles(COMMITS_DIR);
        boolean isFound = false;
        for (String commitFile : commitFiles) {
            Commit commit = Commit.findCommitByUID(commitFile);
            if (commit.getMessage().equals(message)) {
                System.out.println(commit.getUID());
                isFound = true;

            }
        }

        if (!isFound) {
            throw new GitletException("Found no commit with that message.");
        }
    }


    /*
     * Display information about all commits, random orders
     *
     *
     *
     * */
    public static void logGlobally() {
        ArrayList<String> commitFiles = listAllFiles(COMMITS_DIR);
        for (String commitFile : commitFiles) {
            printCommitInfo(commitFile);

        }
    }


    /*
     * Display information of all the commits
     * Starts from the current to the initial commit
     * If there is merged commit that has two parents,
     * Only follow the first parent commit chain
     * First parent means the commit that the user is on
     * when calling the merge method
     * Display every commit's commit ID, time, and message
     * //for merged commit add a  Merge line, do this later
     * //The first is the first parent's first seven digit id
     * //so is the second
     *
     *
     * */
    public static void log() {
        Commit currentCommit = Commit.findCurrentCommit();
        ArrayList<String> allParentCommits = currentCommit.getParentCommit();
        //
        printCommitInfo(currentCommit.getUID());
        for (int i = allParentCommits.size() - 1; i >= 0; i--) {
            printCommitInfo(allParentCommits.get(i));
        }


    }

    public static void printCommitInfo(String commitID) {
        System.out.println("===");
        Commit commit = Commit.findCommitByUID(commitID);
        System.out.println("commit " + commit.getUID());
        System.out.println("Date: " + commit.getTimeStamp());
        System.out.println(commit.getMessage());
        System.out.println();
    }


    /*
     * Unstage the file if it is currently in the staging area
     * Check if the file is being tracked in the current commit
     * Remove it from the commit only when user says commit
     * Remove it from the working directory when the user says commit too
     * // so you need change the code for commit method
     *
     * Exception: If the file is not in the staging area and not in
     * the current commit, error  No reason to remove the file.
     *
     *
     *
     * if the file is in the staging area, remove the entry
     * if it is also in the current commit, add this file to staging area and mark it as "rm" //and remove it
     * in the commit function if a file points to "rm" in the staging area, the file will not exist in the new commit
     * and the file will be removed(no remove it in the remove function this needs modifying)

     *
     * */
    public static void rm(String file) throws GitletException {
        Map<String, String> stagingArea = StagingArea.readStagingArea();
        boolean containsInStagingArea = stagingArea.containsKey(file);
        if (containsInStagingArea) {
            stagingArea.remove(file);
        }
        Commit currentCommit = Commit.findCurrentCommit();
        //if current commit contains the key, mark it for removal
        boolean containsInCurrentCommit = currentCommit.getFilesMap().containsKey(file);
        //if the file is tracked in the current commit
        //mark the file as rm so next commit will not have the file tracked
        //and delete the file in the wd
        if (containsInCurrentCommit) {
            stagingArea.put(file, "rm");
            File fileToRemove = Utils.join(CWD, file);
            Utils.restrictedDelete(fileToRemove);


        }
        if (containsInStagingArea == false && containsInCurrentCommit == false) {
            throw new GitletException("No reason to remove the file");
        }
        StagingArea.saveStagingArea(stagingArea);


    }


    /*
    *Create a new commit that tracks the saved files in the staging area
    * By default, the new commit's filemap is the same as its parents'
    *
    * The file in the original map will point to the new version in the staging area
    * //addition: A file tracked in the parent commit if some used rm command,do this later
    * The date of the commit will be different
    * The method will clear the staging area after a commit
    *
    * The commit's parents class will be the current head(and include the current head's parent class)
    * The head pointer will point to the new commit just made
    * Exceptions: if staging area is empty, print error No changes added to the
commit.
*If no message print Please enter a commit message.
*
*
* Make and save a new commit that is the same as its parents, update the time stamp
* update the parent class of the new commit
* update the fileMap
* update the head
* if the a file points to "rm" in staging area, remove the file in the CWD
* and update the commit to not include the file anymore
*
*
    * */
    public static void commit(String message) throws GitletException {

        Map<String, String> stagingArea = StagingArea.readStagingArea();
        if (stagingArea.size() == 0) {
            throw new GitletException("No changes added to the commit.");

        }
        //Get the current commit
        Commit currentCommit = Commit.findCurrentCommit();
        //String message, ArrayList<String> parentCommit, Map<String,String> filesMap
        ArrayList<String> newParentCommit = currentCommit.getParentCommit();
        //Parent commit is an alist of commits, the left most commits or the earliest commit on the index 0
        //We will add the current commit to the new commit's parent commit
        //[commit 0, commit 1,..... current commit] <-- newCommit
        newParentCommit.add(currentCommit.getUID());

        Map<String, String> currentFileMap = currentCommit.getFilesMap();
        Map<String, String> newFileMap = StagingArea.updateCommitMap(stagingArea, currentFileMap);
        System.out.println(newFileMap);

        //We update the message, new parent commit, and new file map

        Commit newCommit = new Commit(message, newParentCommit, newFileMap);
        //if staging area has 'rm' for a file, it will be deleted in WD when commiting// no you do not need to, delete it in rm method

        //restore the staging area
        Map<String, String> clearedStagingArea = new HashMap<String, String>();
        System.out.println("The current commit mapping is " + newCommit.getFilesMap());
        StagingArea.saveStagingArea(clearedStagingArea);


    }
    //added a feature of a second parent
       public static void mergeCommit(String message, String secondParentCommitID) throws GitletException {

        Map<String, String> stagingArea = StagingArea.readStagingArea();
        if (stagingArea.size() == 0) {
            throw new GitletException("No changes added to the commit.");

        }
        //Get the current commit
        Commit currentCommit = Commit.findCurrentCommit();
        //String message, ArrayList<String> parentCommit, Map<String,String> filesMap
        ArrayList<String> newParentCommit = currentCommit.getParentCommit();
        //Parent commit is an alist of commits, the left most commits or the earliest commit on the index 0
        //We will add the current commit to the new commit's parent commit
        //[commit 0, commit 1,..... current commit] <-- newCommit
        newParentCommit.add(currentCommit.getUID());

        Map<String, String> currentFileMap = currentCommit.getFilesMap();
        Map<String, String> newFileMap = StagingArea.updateCommitMap(stagingArea, currentFileMap);
        System.out.println(newFileMap);

        //get the parent commits of the given branch commit and add that branch commit to the parent commits of the new commit
           ArrayList<String> secondParentCommit = Commit.findCommitByUID(secondParentCommitID).getParentCommit();
           secondParentCommit.add(secondParentCommitID);
          //We update the message, new parent commit, and new file map
        Commit newCommit = new Commit(message, newParentCommit,secondParentCommit, newFileMap);
        //if staging area has 'rm' for a file, it will be deleted in WD when commiting// no you do not need to, delete it in rm method

        //restore the staging area
        Map<String, String> clearedStagingArea = new HashMap<String, String>();
        System.out.println("The current commit mapping is " + newCommit.getFilesMap());
        StagingArea.saveStagingArea(clearedStagingArea);


    }


    /* TODO: fill in the rest of this class. */
    //Creates a new .versio file in the current directory
    /*
     * Have the initial commit, no files tracked stored in .versio
     * Commit msg = "initial commit"
     * Create a new branch: master, points to the above commit
     * Set the commit metadeta, its time is 1970...
     * And its UID
     * Exits if error occured, A Gitlet version-control system already exists in the current directory
     * puts a blank map in staging area
     * */
    public static void initRepository() throws GitletException {

        File gitletDir = GITLET_DIR;
        if (gitletDir.exists()) {
            throw new GitletException("A Gitlet version-control system already exists in the current directory");
        }
        gitletDir.mkdir();
        File stagingArea = STAGING_AREA;
        stagingArea.mkdir();
        Commit initialCommit = new Commit();

        Map<String, String> blankStagingArea = new HashMap<>();
        StagingArea.saveStagingArea(blankStagingArea);


    }

    public static ArrayList<String> listAllFiles(File dir) throws GitletException {
        if (Utils.plainFilenamesIn(dir) == null) {
            return new ArrayList<String>();
        }
        return new ArrayList<String>(Utils.plainFilenamesIn(dir));
    }

    public static String makeBlobAndSaveFrom(File fileToAdd) {
        byte[] blob = Utils.readContents(fileToAdd);
        String blobID = Utils.sha1(blob);
        Blob.saveBlob(blob, blobID);
        return blobID;
    }

    public static String makeBlobWithoutSaving(File fileToAdd) {
        byte[] blob = Utils.readContents(fileToAdd);
        String blobID = Utils.sha1(blob);
        return blobID;
    }


    //find the commit object provided
    /*
     * get its file map
     * if the map contains the file, check if the blob ID is the same
     * if the same return the FileName of that file
     * */
    public static String compareFilesBlobInCommit(String commit, String fileName, String blobID) {
        Commit commitToCompare = Commit.findCommitByUID(commit);
        Map<String, String> commitFileMap = commitToCompare.getFilesMap();
        if (commitFileMap.containsKey(fileName)) {
            if (commitFileMap.get(fileName).equals(blobID)) {
                return commit;
            } else {
                System.out.println("The commit file version is not equal to the current version");
                return null;
            }
        }
        System.out.println("The commit does not include the file");
        return null;

    }

    /*

    *Add a blob of a file to the staging area
    If the file is already in the staging area, we rewrite the blob
    If the added file is the same as what is the current commit,
    do not add and remove it if it is already inside
    * */
    public static void add(String... addedFile) throws GitletException {
        ArrayList<String> CWDFiles = listAllFiles(CWD);
        System.out.println(CWDFiles);

        ArrayList<String> stagingAreaFiles = listAllFiles(STAGING_AREA);
        File fileToAdd = join(CWD, addedFile[0]);
        String blobID = makeBlobAndSaveFrom(fileToAdd);// create a blob and save it from a file
        // Read the mapping in staging area
        Map<String, String> stagingArea = StagingArea.readStagingArea();

        System.out.println(stagingArea);
        //If the key (filename) already exists, update it
        if (stagingArea.containsKey(addedFile[0])) {
            stagingArea.put(addedFile[0], blobID);
        } else {
            stagingArea.put(addedFile[0], blobID);
        }

        ///check if the current commit's file version equal to the added one
        //if so, remove the key from staging area
        String duplicateVersion = compareFilesBlobInCommit(Commit.findCurrentCommit().getUID(), addedFile[0], blobID);
        if (duplicateVersion != null) {
            if (stagingArea.containsKey(addedFile[0])) {
                stagingArea.remove(addedFile[0]);
            }
        }
        StagingArea.saveStagingArea(stagingArea);
        System.out.println("the staging area currently contains" + stagingArea);


//        fileMapToBlob.put(addedFile[0], blobID);
//
//
//
//        StagingArea.saveStagingArea(fileMapToBlob);


//        boolean isInStagingArea = false;
//        for (String file : addedFile) {
//            if (stagingAreaFiles.contains(file)) {
//                isInStagingArea = true;
//            }
//
//        }


    }


}

================
File: versio/StagingArea.java
================
package versio;

import java.io.File;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

public class StagingArea {
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<>();
        map.put("1", "d");
        map.put("2", "a");
        map.put("3", "b");
        map.put("4", "c");
        map.put("5", "d");

        Map<String,String> stagingArea = new HashMap<>();
        stagingArea.put("1", "a");
        stagingArea.put("4", "rm");
        Map<String, String> modified = updateCommitMap(stagingArea, map);
        System.out.println(updateCommitMap(stagingArea,map));
    }


    //FileToBlob means fileMap
    public static void saveStagingArea(Map<String, String> fileToBlob) {
        Repository.STAGING_AREA.mkdir();
        File stagingArea = Utils.join(Repository.STAGING_AREA, "STAGING_AREA");
        Utils.writeObject(stagingArea, (Serializable) fileToBlob);

    }
    //need testing
    //update all the file entry inside
    //if the file is labeled as rm
    //remove the file from the commitMap



    public static Map<String, String> updateCommitMap(Map<String, String> stagingArea, Map<String, String> commitMap) {
        for(String key: stagingArea.keySet()) {


            if (stagingArea.get(key).equals("rm")) {
                commitMap.remove(key);
            } else {
                String value = stagingArea.get(key);
                commitMap.put(key, value);
            }
        }
        return commitMap;
    }

    public static Map<String, String> readStagingArea() {

        File stagingArea = Utils.join(Repository.STAGING_AREA, "STAGING_AREA");
        return Utils.readObject(stagingArea, HashMap.class);
    }
}

================
File: versio/Utils.java
================
package versio;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Formatter;
import java.util.List;


/** Assorted utilities.
 *
 * Give this file a good read as it provides several useful utility functions
 * to save you some time.
 *
 *  @author P. N. Hilfinger
 */
class    Utils {

    /** The length of a complete SHA-1 UID as a hexadecimal numeral. */
    static final int UID_LENGTH = 40;

    /* SHA-1 HASH VALUES. */

    /** Returns the SHA-1 hash of the concatenation of VALS, which may
     *  be any mixture of byte arrays and Strings. */
    static String sha1(Object... vals) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            for (Object val : vals) {
                if (val instanceof byte[]) {
                    md.update((byte[]) val);
                } else if (val instanceof String) {
                    md.update(((String) val).getBytes(StandardCharsets.UTF_8));
                } else {
                    throw new IllegalArgumentException("improper type to sha1");
                }
            }
            Formatter result = new Formatter();
            for (byte b : md.digest()) {
                result.format("%02x", b);
            }
            return result.toString();
        } catch (NoSuchAlgorithmException excp) {
            throw new IllegalArgumentException("System does not support SHA-1");
        }
    }

    /** Returns the SHA-1 hash of the concatenation of the strings in
     *  VALS. */
    static String sha1(List<Object> vals) {
        return sha1(vals.toArray(new Object[vals.size()]));
    }

    /* FILE DELETION */

    /** Deletes FILE if it exists and is not a directory.  Returns true
     *  if FILE was deleted, and false otherwise.  Refuses to delete FILE
     *  and throws IllegalArgumentException unless the directory designated by
     *  FILE also contains a directory named .versio. */
    static boolean restrictedDelete(File file) {
        if (!(new File(file.getParentFile(), ".versio")).isDirectory()) {
            throw new IllegalArgumentException("not .versio working directory");
        }
        if (!file.isDirectory()) {
            return file.delete();
        } else {
            return false;
        }
    }

    /** Deletes the file named FILE if it exists and is not a directory.
     *  Returns true if FILE was deleted, and false otherwise.  Refuses
     *  to delete FILE and throws IllegalArgumentException unless the
     *  directory designated by FILE also contains a directory named .versio. */
    static boolean restrictedDelete(String file) {
        return restrictedDelete(new File(file));
    }

    /* READING AND WRITING FILE CONTENTS */

    /** Return the entire contents of FILE as a byte array.  FILE must
     *  be a normal file.  Throws IllegalArgumentException
     *  in case of problems. */
    static byte[] readContents(File file) {
        if (!file.isFile()) {
            throw new IllegalArgumentException("must be a normal file");
        }
        try {
            return Files.readAllBytes(file.toPath());
        } catch (IOException excp) {
            throw new IllegalArgumentException(excp.getMessage());
        }
    }

    /** Return the entire contents of FILE as a String.  FILE must
     *  be a normal file.  Throws IllegalArgumentException
     *  in case of problems. */
    static String readContentsAsString(File file) {
        return new String(readContents(file), StandardCharsets.UTF_8);
    }

    /** Write the result of concatenating the bytes in CONTENTS to FILE,
     *  creating or overwriting it as needed.  Each object in CONTENTS may be
     *  either a String or a byte array.  Throws IllegalArgumentException
     *  in case of problems. */
    static void writeContents(File file, Object... contents) {
        try {
            if (file.isDirectory()) {
                throw
                    new IllegalArgumentException("cannot overwrite directory");
            }
            BufferedOutputStream str =
                new BufferedOutputStream(Files.newOutputStream(file.toPath()));
            for (Object obj : contents) {
                if (obj instanceof byte[]) {
                    str.write((byte[]) obj);
                } else {
                    str.write(((String) obj).getBytes(StandardCharsets.UTF_8));
                }
            }
            str.close();
        } catch (IOException | ClassCastException excp) {
            throw new IllegalArgumentException(excp.getMessage());
        }
    }

    /** Return an object of type T read from FILE, casting it to EXPECTEDCLASS.
     *  Throws IllegalArgumentException in case of problems. */
    static <T extends Serializable> T readObject(File file,
                                                 Class<T> expectedClass) {
        try {
            ObjectInputStream in =
                new ObjectInputStream(new FileInputStream(file));
            T result = expectedClass.cast(in.readObject());
            in.close();
            return result;
        } catch (IOException | ClassCastException
                 | ClassNotFoundException excp) {
            throw new IllegalArgumentException(excp.getMessage());
        }
    }

    /** Write OBJ to FILE. */
    static void writeObject(File file, Serializable obj) {
        writeContents(file, serialize(obj));
    }

    /* DIRECTORIES */

    /** Filter out all but plain files. */
    private static final FilenameFilter PLAIN_FILES =
        new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return new File(dir, name).isFile();
            }
        };

    /** Returns a list of the names of all plain files in the directory DIR, in
     *  lexicographic order as Java Strings.  Returns null if DIR does
     *  not denote a directory. */
    static List<String> plainFilenamesIn(File dir) {
        String[] files = dir.list(PLAIN_FILES);
        if (files == null) {
            return null;
        } else {
            Arrays.sort(files);
            return Arrays.asList(files);
        }
    }

    /** Returns a list of the names of all plain files in the directory DIR, in
     *  lexicographic order as Java Strings.  Returns null if DIR does
     *  not denote a directory. */
    static List<String> plainFilenamesIn(String dir) {
        return plainFilenamesIn(new File(dir));
    }

    /* OTHER FILE UTILITIES */

    /** Return the concatentation of FIRST and OTHERS into a File designator,
     *  analogous to the {@link java.nio.file.Paths.#get(String, String[])}
     *  method. */
    static File join(String first, String... others) {
        return Paths.get(first, others).toFile();
    }

    /** Return the concatentation of FIRST and OTHERS into a File designator,
     *  analogous to the {@link java.nio.file.Paths.#get(String, String[])}
     *  method. */
    static File join(File first, String... others) {
        return Paths.get(first.getPath(), others).toFile();
    }


    /* SERIALIZATION UTILITIES */

    /** Returns a byte array containing the serialized contents of OBJ. */
    static byte[] serialize(Serializable obj) {
        try {
            ByteArrayOutputStream stream = new ByteArrayOutputStream();
            ObjectOutputStream objectStream = new ObjectOutputStream(stream);
            objectStream.writeObject(obj);
            objectStream.close();
            return stream.toByteArray();
        } catch (IOException excp) {
            throw error("Internal error serializing commit.");
        }
    }



    /* MESSAGES AND ERROR REPORTING */

    /** Return a GitletException whose message is composed from MSG and ARGS as
     *  for the String.format method. */
    static GitletException error(String msg, Object... args) {
        return new GitletException(String.format(msg, args));
    }

    /** Print a message composed from MSG and ARGS as for the String.format
     *  method, followed by a newline. */
    static void message(String msg, Object... args) {
        System.out.printf(msg, args);
        System.out.println();
    }
}

================
File: Makefile
================
# This makefile is defined to give you the following targets:
#
#    default: The default target: Compiles the program in package db61b.
#    check: Compiles the versio package, if needed, and then performs the
#           tests described in testing/Makefile.
#    clean: Remove regeneratable files (such as .class files) produced by
#           other targets and Emacs backup files.
#
# In other words, type 'make' to compile everything; 'make check' to 
# compile and test everything, and 'make clean' to clean things up.
# 
# You can use this file without understanding most of it, of course, but
# I strongly recommend that you try to figure it out, and where you cannot,
# that you ask questions.  The Lab Reader contains documentation.

# Name of package containing main procedure 
PACKAGE = versio

# The name of the Python 3 program, used in the 'check' target.  If your system
# has a different name for this program (such as just "python"), run
# the Makefile with
#	make PYTHON=python check
PYTHON = python3

# Flags to pass to tester.py.
TESTER_FLAGS =

RMAKE = "$(MAKE)"

# Targets that don't correspond to files, but are to be treated as commands.
.PHONY: default check clean

default:
	$(RMAKE) -C $(PACKAGE) default

check: default
	$(RMAKE) -C testing PYTHON=$(PYTHON) TESTER_FLAGS="$(TESTER_FLAGS)" check

# 'make clean' will clean up stuff you can reconstruct.
clean:
	$(RM) *~
	$(RMAKE) -C $(PACKAGE) clean
	$(RMAKE) -C testing clean

================
File: README.md
================
My current version of git is capable of these commands

Setting up:

It needs a command-line software to run, such as Git or CMD from Windows. The user has to go to the directory and javac versio/*.java to compile .java into .class files. My Git software will read the user's command line arguments. The format is as such: java Gitlet.Main init, java Gitlet.Main merge Master, java Gitlet.Main commit 'message' ....
 
My software stores different objects as files in the .versio directory, so the software has persistence. Even if the user reboots the computer, my program can start from the point where the user was at.
 
java Gitlet.Main init:

The software creates .versio software to achieve persistence and store commits, blobs and other files.
 
java Gitlet.Main add [fileName](eg. java Gitlet.Main add CS.txt):

The file is added to the staging area for addition. Once the user hits commit, the software will take the snapshot of the file and store the relation between the file and blob(blob means the actual content of the file) into a Hashmap of strings.

java Gitlet.Main commit [commitMessage]: 

The user inputs a message and adds the commit object(with a unique SHA-1 ID) to the commit directory in .versio. The snapshots of the files(fileName ---> Blob) are stored in that commit and the commit is serialized in the computer. User can checkout the commit and restore their file as tracked.

java Gitlet.Main branch [branchName]:
  
The user can create a new branch pointer that points to the current commit, the head pointer will not be changed to the new branch for now.
 
java Gitlet.Main log/ java Gitlet.Main status:

The user can use log to see all commits in the current chain of commits. They can use status to check out these statuses:
Branches that exist
Files in the staging area, including files staged for addition and files staged for removal
Modified files that have not been staged
Files that are untracked in the CWD

java Gitlet.Main checkout [branchName]/ java Gitlet.Main checkout -- [fileName]/ java Gitlet.Main checkout [commitID] -- [fileName]

Users can use checkout to move the Head pointer to a different branch, and restore the files back to the version in that branch commit.
  
Or with different command arguments, the user can also choose to checkout a file in the current commit. They can also checkout a file in a commit by providing the commit ID and the file name.

Above are the software features that have already been realized.

================
File: testing/Makefile
================
# This makefile is defined to give you the following targets:
#
#    default: Same as check
#    check: Run the integration tests.
#    clean: Remove all files and directories generated by testing.
#

SHELL = /bin/bash

# Flags to Java interpreter: check assertions
JFLAGS = -ea

# See comment in ../Makefile
PYTHON = python3

RMAKE = "$(MAKE)"

TESTER = CLASSPATH="$$(pwd)/..:$(CLASSPATH):;$$(pwd)/..;$(CLASSPATH)" $(PYTHON) tester.py

TESTER_FLAGS =

TESTS = samples/*.in student_tests/*.in *.in

.PHONY: default check clean std

# First, and therefore default, target.
default:
	$(RMAKE) -C .. 
	$(RMAKE) PYTHON=$(PYTHON) check

check:
	@echo "Testing application versio.Main..."
	$(TESTER) $(TESTER_FLAGS) $(TESTS)

# 'make clean' will clean up stuff you can reconstruct.
clean:
	$(RM) -r */*~ *~ __pycache__

================
File: testing/runner.py
================
import sys, re
from subprocess import \
    check_output, PIPE, STDOUT, DEVNULL, CalledProcessError, TimeoutExpired
from os.path import abspath, basename, dirname, exists, join, splitext, isdir
from getopt import getopt, GetoptError
from os import chdir, environ, getcwd, mkdir, remove
from shutil import copyfile, rmtree
from math import log
from glob import glob

SHORT_USAGE = """\
Usage: python3 runner.py OPTIONS TEST.in ...
   OPTIONS may include
       --keep         Keep test directories
       --lib=DIR   Relative path to directory containing CS61BL libraries
       --timeout=SEC  Default number of seconds allowed to each execution
                      of versio.
       --src=SRC      Use SRC instead of "src" as the subdirectory containing
                      files referenced by + and =.
       --tolerance=N  Set the maximum allowed edit distance between program
                      output and expected output to N (default 3).
       --verbose      Print extra information about execution.
"""

USAGE = SHORT_USAGE + """\

For each TEST.in, change to an empty directory, and execute the instructions
in TEST.in.  Before executing an instruction, first replace any occurrence
of ${VAR} with the current definition of VAR (see the D command below).
Replace any occurrence of ${N} for non-negative decimal numeral N with
the value of the Nth captured group in the last ">" command's expected
output lines.  Undefined if the last ">" command did not end in "<<<*",
or did not have the indicated group. N=0 indicates the entire matched string.

The instructions each have one of the following forms:

   # ...  A comment, producing no effect.
   I FILE Include.  Replace this statement with the contents of FILE,
          interpreted relative to the directory containing the .in file.
   C DIR  Create, if necessary, and switch to a subdirectory named DIR under
          the main directory for this test.  If DIR is missing, changes
          back to the default directory.  This command is principally
          intended to let you set up remote repositories.
   T N    Set the timeout for versio commands in the rest of this test to N
          seconds.
   + NAME F
          Copy the contents of src/F into a file named NAME.
   - NAME
          Delete the file named NAME.
   > COMMAND OPERANDS
   LINE1
   LINE2
   ...
   <<<
          Run versio.Main with COMMAND ARGUMENTS as its parameters.  Compare
          its output with LINE1, LINE2, etc., reporting an error if there is
          "sufficient" discrepency.  The <<< delimiter may be followed by
          an asterisk (*), in which case, the preceding lines are treated as 
          Python regular expressions and matched accordingly. The directory
          or JAR file containing the versio.Main program is assumed to be
          in directory DIR specifed by --progdir (default is ..).
   = NAME F
          Check that the file named NAME is identical to src/F, and report an
          error if not.
   * NAME
          Check that the file NAME does not exist, and report an error if it
          does.
   E NAME
          Check that file or directory NAME exists, and report an error if it
          does not.
   D VAR "VALUE"
          Defines the variable VAR to have the literal value VALUE.  VALUE is
          taken to be a raw Python string (as in r"VALUE").  Substitutions are
          first applied to VALUE.

For each TEST.in, reports at most one error.  Without the --show option,
simply indicates tests passed and failed.  If N is postive, also prints details
of the first N failing tests. With --show=all, shows details of all failing
tests.  With --keep, keeps the directories created for the tests (with names
TEST.dir).

When finished, reports number of tests passed and failed, and the number of
faulty TEST.in files."""


DIRECTORY_LAYOUT_ERROR = """\
Your {} folder is not where we expected it. Please ensure that your directory
structure matches the following:

sp21-s***
  ├── library-sp21
  │    └── ...
  ├── proj2
  │   ├── versio
  │   ├── testing <==== This should be your CWD
  │   │    ├── runner.py
  │   │    └── ...
  │   └── ...
  └── ...

Note your CWD must be `sp21-s***/proj2/testing`

Also check that your REPO_DIR environment variable is the path to your
`sp21-s***` directory. You can check this by running the command:

    $ echo REPO_DIR
    /Users/omarkhan902/cs61b/61b_sp21_stuff/sp21-s3

That's what mine looks like. Go back to lab1 if you are still having issues"""

JAVA_COMMAND = "java"
CAPERS_COMMAND = "versio.Main"
JAVAC_COMMAND = "javac -d ."
JVM_COMMAND = "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005"
TIMEOUT = 10
DEBUG = False
DEBUG_MSG = \
    """
   ============================================================================
  |                   ~~~~~  You are in debug mode  ~~~~~                      |
  |   In this mode, you will be shown each command from the test case.         |
  |                                                                            |
  |   There are three commands:                                                |
  |                                                                            |
  |   1. 'n' - type in 'n' to go to the next command without debugging the     |
  |            current one (analogous to "Step Over" in IntelliJ).             |
  |                                                                            |
  |   2. 's' - type in 's' to debug the current command (analogous to          |
  |            "Step Into" in IntelliJ). Make sure to set breakpoints!         |
  |                                                                            |
  |   3. 'q' - type in 'q' to quit and stop debugging. If you had the `--keep` |
  |            flag, then your directory state will be saved and you can       |
  |            investigate it.                                                 |
   ============================================================================
"""

def Usage():
    print(SHORT_USAGE, file=sys.stderr)
    sys.exit(1)

Mat = None
def Match(patn, s):
    global Mat
    Mat = re.match(patn, s)
    return Mat

def Group(n):
    return Mat.group(n)

def contents(filename):
    try:
        with open(filename) as inp:
            return inp.read()
    except FileNotFoundError:
        return None

def editDistance(s1, s2):
    dist = [list(range(len(s2) + 1))] + \
           [ [i] + [ 0 ] * len(s2) for i in range(1, len(s1) + 1) ]
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            dist[i][j] = min(dist[i-1][j] + 1,
                             dist[i][j-1] + 1,
                             dist[i-1][j-1] + (s1[i-1] != s2[j-1]))
    return dist[len(s1)][len(s2)]

def nextCommand(full_cmnd, timeout):
    return check_output(full_cmnd, shell=True, universal_newlines=True,
                        stdin=DEVNULL, stderr=STDOUT, timeout=timeout)
def stepIntoCommand(full_cmnd):
    out = check_output(full_cmnd, shell=True, universal_newlines=True,
                       stdin=DEVNULL, stderr=STDOUT, timeout=None)
    return out.split("\n", 1)[1]

def createTempDir(base):
    for n in range(100):
        name = "{}_{}".format(base, n)
        try:
            mkdir(name)
            return name
        except OSError:
            pass
    else:
        raise ValueError("could not create temp directory for {}".format(base))

def cleanTempDir(dir):
    rmtree(dir, ignore_errors=True)

def doDelete(name, dir):
    try:
        remove(join(dir, name))
    except OSError:
        pass

def doCopy(dest, src, dir):
    try:
        doDelete(dest, dir)
        copyfile(join(src_dir, src), join(dir, dest))
    except OSError:
        raise ValueError("file {} could not be copied to {}".format(src, dest))

def doCompile(target):
    out = ""
    try:
        full_cmnd = "{} {}".format(JAVAC_COMMAND, target)
        out = check_output(full_cmnd, shell=True, universal_newlines=True,
                           stdin=DEVNULL, stderr=STDOUT)
        return "OK", out
    except CalledProcessError as excp:
        return ("javac exited with code {}".format(excp.args[0]),
                excp.output)

def doExecute(cmnd, dir, timeout):
    here = getcwd()
    out = ""
    try:
        chdir(dir)
        full_cmnd = "{} {} {}".format(JAVA_COMMAND, CAPERS_COMMAND, cmnd)

        if DEBUG:
            print(">>> versio {}".format(cmnd))
            next_cmd = input("> ").strip().lower()
            while(next_cmd not in {'s', 'n', 'q'}):
                print("Please enter either 'n' or 's'.")
                next_cmd = input("> ").strip().lower()

            if next_cmd == "n":
                out = nextCommand(full_cmnd, timeout)
            elif next_cmd == "s":
                full_cmnd = "{} {} {} {}".format(JAVA_COMMAND, JVM_COMMAND, CAPERS_COMMAND, cmnd)
                print(f"Ready to debug the command `versio {cmnd}`")
                print("Open IntelliJ and hit the \"Debug\" button. Don't forget to set a breakpoint!")
                out = stepIntoCommand(full_cmnd)
            elif next_cmd == "q":
                return "User Exit", None
        else:
            out = nextCommand(full_cmnd, timeout)

        if superverbose:
            print(out)

        return "OK", out
    except CalledProcessError as excp:
        return ("java versio.Main exited with code {}".format(excp.args[0]),
                excp.output)
    except TimeoutExpired:
        return "timeout", None
    finally:
        chdir(here)

def canonicalize(s):
    if s is None:
        return None
    return re.sub('\r', '', s)

def fileExists(f, dir):
    return exists(join(dir, f))

def correctFileOutput(name, expected, dir):
    userData = canonicalize(contents(join(dir, name)))
    stdData = canonicalize(contents(join(src_dir, expected)))
    return userData == stdData

def correctProgramOutput(expected, actual, last_groups, is_regexp):
    expected = re.sub(r'[ \t]+\n', '\n', '\n'.join(expected))
    expected = re.sub(r'(?m)^[ \t]+', ' ', expected)
    actual = re.sub(r'[ \t]+\n', '\n', actual)
    actual = re.sub(r'(?m)^[ \t]+', ' ', actual)

    last_groups[:] = (actual,)
    if is_regexp:
        try:
            if not Match(expected.rstrip() + r"\Z", actual) \
                    and not Match(expected.rstrip() + r"\Z", actual.rstrip()):
                return False
        except:
            raise ValueError("bad pattern")
        last_groups[:] += Mat.groups()
    elif editDistance(expected.rstrip(), actual.rstrip()) > output_tolerance:
        return False
    return True

def reportDetails(test, included_files, line_num):
    if show is None:
        return
    if show <= 0:
        print("   Limit on error details exceeded.")
        return
    direct = dirname(test)

    print("    Error on line {} of {}".format(line_num, basename(test)))

    for base in [basename(test)] + included_files:
        full = join(dirname(test), base)
        print(("-" * 20 + " {} " + "-" * 20).format(base))
        text_lines = list(enumerate(re.split(r'\n\r?', contents(full))))[:-1]
        fmt = "{{:{}d}}. {{}}".format(round(log(len(text_lines), 10)))
        text = '\n'.join(map(lambda p: fmt.format(p[0] + 1, p[1]), text_lines))
        print(text)
        print("-" * (42 + len(base)))

def chop_nl(s):
    if s and s[-1] == '\n':
        return s[:-1]
    else:
        return s

def line_reader(f, prefix):
    n = 0
    try:
        with open(f) as inp:
            while True:
                L = inp.readline()
                if L == '':
                    return
                n += 1
                included_file = yield (prefix + str(n), L)
                if included_file:
                    yield None
                    yield from line_reader(included_file, prefix + str(n) + ".")
    except FileNotFoundError:
        raise ValueError("file {} not found".format(f))

def doTest(test):
    last_groups = []
    base = splitext(basename(test))[0]
    print("{}:".format(base), end=" \n")
    cdir = tmpdir = createTempDir(base)
    if verbose:
        print("Testing directory: {}".format(tmpdir))
    timeout = TIMEOUT
    defns = {}

    def do_substs(L):
        c = 0
        L0 = None
        while L0 != L and c < 10:
            c += 1
            L0 = L
            L = re.sub(r'\$\{(.*?)\}', subst_var, L)
        return L

    def subst_var(M):
        key = M.group(1)
        if Match(r'\d+$', key):
            try:
                return last_groups[int(key)]
            except IndexError:
                raise ValueError("FAILED (nonexistent group: {{{}}})"
                                 .format(key))
        elif M.group(1) in defns:
            return defns[M.group(1)]
        else:
            raise ValueError("undefined substitution: ${{{}}}".format(M.group(1)))

    try:
        line_num = None
        inp = line_reader(test, '')
        included_files = []
        while True:
            line_num, line = next(inp, (line_num, ''))
            if line == "":
                print("OK")
                return True
            if not Match(r'\s*#', line):
                line = do_substs(line)
            if verbose:
                print("+ {}".format(line.rstrip()))
            if Match(r'\s*#', line) or Match(r'\s+$', line):
                pass
            elif Match(r'I\s+(\S+)', line):
                inp.send(join(dirname(test), Group(1)))
                included_files.append(Group(1))
            elif Match(r'C\s*(\S*)', line):
                if Group(1) == "":
                    cdir = tmpdir
                else:
                    cdir = join(tmpdir, Group(1))
                    if not exists(cdir):
                        mkdir(cdir)
            elif Match(r'T\s*(\S+)', line):
                try:
                    timeout = float(Group(1))
                except:
                    ValueError("bad time: {}".format(line))
            elif Match(r'\+\s*(\S+)\s+(\S+)', line):
                doCopy(Group(1), Group(2), cdir)
            elif Match(r'-\s*(\S+)', line):
                doDelete(Group(1), cdir)
            elif Match(r'>\s*(.*)', line):
                cmnd = Group(1)
                expected = []
                while True:
                    line_num, L = next(inp, (line_num, ''))
                    if L == '':
                        raise ValueError("unterminated command: {}"
                                         .format(line))
                    L = L.rstrip()
                    if Match(r'<<<(\*?)', L):
                        is_regexp = Group(1)
                        break
                    expected.append(do_substs(L))
                msg, out = doExecute(cmnd, cdir, timeout)
                if verbose:
                    if out:
                        print(re.sub(r'(?m)^', '- ', chop_nl(out)))
                if msg == "OK":
                    if not correctProgramOutput(expected, out, last_groups,
                                                is_regexp):
                        msg = "incorrect output"
                elif msg == "User Exit":
                    print("Exiting Debug mode ...")
                    break
                if msg != 'OK':
                    print("ERROR ({})".format(msg))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'=\s*(\S+)\s+(\S+)', line):
                if not correctFileOutput(Group(1), Group(2), cdir):
                    print("ERROR (file {} has incorrect content)"
                          .format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'\*\s*(\S+)', line):
                if fileExists(Group(1), cdir):
                    print("ERROR (file {} present)".format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'E\s*(\S+)', line):
                if not fileExists(Group(1), cdir):
                    print("ERROR (file or directory {} not present)"
                          .format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'(?s)D\s*([a-zA-Z_][a-zA-Z_0-9]*)\s*"(.*)"\s*$', line):
                defns[Group(1)] = Group(2)
            else:
                raise ValueError("bad test line at {}".format(line_num))
    finally:
        if not keep:
            cleanTempDir(tmpdir)
        else:
            print(f"\nDirectory state saved in {tmpdir}")

if __name__ == "__main__":
    show = None
    keep = False
    lib_dir = None
    verbose = False
    superverbose = False
    src_dir = 'src'
    gitlet_dir = join(dirname(abspath(getcwd())), "versio")
    output_tolerance = 0

    try:
        opts, files = \
            getopt(sys.argv[1:], '',
                   ['show=', 'keep', 'lib=', 'verbose', 'src=',
                    'tolerance=', 'superverbose', 'debug'])
        for opt, val in opts:
            if opt == '--show':
                show = int(val)
            elif opt == "--keep":
                keep = True
            elif opt == "--lib":
                lib_dir = val
            elif opt == "--src":
                src_dir = val
            elif opt == "--verbose":
                verbose = True
            elif opt == "--tolerance":
                output_tolerance = int(val)
            elif opt == "--superverbose":
                superverbose = True
            elif opt == "--debug":
                DEBUG = True
                TIMEOUT = 100000
        if lib_dir is None:
            lib_dir = join(abspath(environ['REPO_DIR']),
                           "library-sp21/javalib")
        else:
            lib_dir = join(abspath(getcwd()), abspath(lib_dir))
    except GetoptError:
        Usage()
    if not files:
        print(USAGE)
        sys.exit(0)

    if not isdir(lib_dir):
        print(DIRECTORY_LAYOUT_ERROR.format("lib"))
        sys.exit(1)
    elif not isdir(gitlet_dir):
        print(DIRECTORY_LAYOUT_ERROR.format("versio"))
        sys.exit(1)

    gitlet_dir = "\"" + gitlet_dir + "\"" # in case path has a space in it
    lib_dir = "\"" + lib_dir + "\"" # in case path has a space in it

    lib_glob = join(lib_dir, "*")
    ON_WINDOWS = Match(r'.*\\', join('a', 'b'))
    if ON_WINDOWS:
        if ('CLASSPATH' in environ):
            environ['CLASSPATH'] = "{};{};{}".format(abspath(getcwd()), lib_glob, environ['CLASSPATH'])
        else:
            environ['CLASSPATH'] = "{};{}".format(abspath(getcwd()), lib_glob)
    else:
        if ('CLASSPATH' in environ):
            environ['CLASSPATH'] = "{}:{}:{}".format(abspath(getcwd()), lib_glob, environ['CLASSPATH'])
        else:
            environ['CLASSPATH'] = "{}:{}".format(abspath(getcwd()), lib_glob)
        JAVA_COMMAND = 'exec ' + JAVA_COMMAND
        JAVAC_COMMAND = 'exec ' + JAVAC_COMMAND

    compile_target = join(gitlet_dir, "*.java")
    msg, output = doCompile(compile_target)
    if output.find("error") >= 0:
        print(output)
        print("Your program failed to compile. Ran 0 tests.")
        sys.exit(1)

    matching_files = []
    for path in files:
        matching_files += glob(path)
    files = matching_files

    num_tests = len(files)
    errs = 0
    fails = 0

    print(DEBUG_MSG)

    for test in files:
        try:
            if not exists(test):
                num_tests -= 1
            elif not doTest(test):
                errs += 1
                if type(show) is int:
                    show -= 1
        except ValueError as excp:
            print("FAILED ({})".format(excp.args[0]))
            fails += 1

    cleanTempDir(join(abspath(getcwd()), "versio"))

    print()
    print("Ran {} tests. ".format(num_tests), end="")
    if errs == fails == 0:
        print("All passed.")
    else:
        print("{} passed.".format(num_tests - errs - fails))
        sys.exit(1)

================
File: testing/samples/definitions.inc
================
# Standard definitions
D DATE "Date: \w\w\w \w\w\w \d+ \d\d:\d\d:\d\d \d\d\d\d [-+]\d\d\d\d"
# A status log header RE.  Captures the commit id in its sole group.
D COMMIT_HEAD "commit ([a-f0-9]+)[ \t]*\n(?:Merge:\s+[0-9a-f]{7}\s+[0-9a-f]{7}[ ]  *\n)?${DATE}"
# A full log entry.  Captures the entry. Assume logs messages don't contain
# "==="
D COMMIT_LOG "(===[ ]*\ncommit [a-f0-9]+[ ]*\n(?:Merge:\s+[0-9a-f]{7}\s+[0-9a-f]{7}[ ]*\n)?${DATE}[ ]*\n(?:.|\n)*?(?=\Z|\n===))"
# An arbitrary line of text (works even with ?s)
D ARBLINE "[^\n]*(?=\n|\Z)"
# Zero or more arbitrary full lines of text.
D ARBLINES "(?:(?:.|\n)*(?:\n|\Z)|\A|\Z)"

================
File: testing/samples/test01-init.in
================
# Basic initialization
> init
<<<
E .versio

================
File: testing/samples/test02-basic-checkout.in
================
# A simple test of adding, committing, modifying, and checking out.
> init
<<<
+ wug.txt wug.txt
> add wug.txt
<<<
> commit "added wug"
<<<
+ wug.txt notwug.txt
# Must change
> checkout -- wug.txt
<<<
= wug.txt wug.txt

================
File: testing/samples/test03-basic-log.in
================
# Set up a simple chain of commits and check their log.
I definitions.inc
> init
<<<
+ wug.txt wug.txt
> add wug.txt
<<<
> commit "added wug"
<<<
> log
===
${COMMIT_HEAD}
added wug

===
${COMMIT_HEAD}
initial commit

<<<*

================
File: testing/samples/test04-prev-checkout.in
================
# Check that we can check out a previous version.
I definitions.inc
> init
<<<
+ wug.txt wug.txt
> add wug.txt
<<<
> commit "version 1 of wug.txt"
<<<
+ wug.txt notwug.txt
> add wug.txt
<<<
> commit "version 2 of wug.txt"
<<<
= wug.txt notwug.txt
# Each ${COMMIT_HEAD} captures its commit UID.
> log
===
${COMMIT_HEAD}
version 2 of wug.txt

===
${COMMIT_HEAD}
version 1 of wug.txt

===
${COMMIT_HEAD}
initial commit

<<<*
# UID of second version
D UID2 "${1}"
# UID of current version
D UID1 "${2}"
> checkout ${UID1} -- wug.txt
<<<
= wug.txt wug.txt
> checkout ${UID2} -- wug.txt
<<<
= wug.txt notwug.txt

================
File: testing/src/notwug.txt
================
This is not a wug.

================
File: testing/src/wug.txt
================
This is a wug.

================
File: testing/staff-runner.py
================
import sys, re
from subprocess import \
    check_output, PIPE, STDOUT, DEVNULL, CalledProcessError, TimeoutExpired
from os.path import abspath, basename, dirname, exists, join, splitext, isdir
from getopt import getopt, GetoptError
from os import chdir, environ, getcwd, mkdir, remove
from shutil import copyfile, rmtree
from math import log
from glob import glob

SHORT_USAGE = """\
Usage: python3 staff-runner.py OPTIONS TEST.in ...
   OPTIONS may include
       --keep         Keep test directories
       --timeout=SEC  Default number of seconds allowed to each execution
                      of versio.
       --src=SRC      Use SRC instead of "src" as the subdirectory containing
                      files referenced by + and =.
       --tolerance=N  Set the maximum allowed edit distance between program
                      output and expected output to N (default 3).
       --verbose      Print extra information about execution.
"""

USAGE = SHORT_USAGE + """\

For each TEST.in, change to an empty directory, and execute the instructions
in TEST.in.  Before executing an instruction, first replace any occurrence
of ${VAR} with the current definition of VAR (see the D command below).
Replace any occurrence of ${N} for non-negative decimal numeral N with
the value of the Nth captured group in the last ">" command's expected
output lines.  Undefined if the last ">" command did not end in "<<<*",
or did not have the indicated group. N=0 indicates the entire matched string.

The instructions each have one of the following forms:

   # ...  A comment, producing no effect.
   I FILE Include.  Replace this statement with the contents of FILE,
          interpreted relative to the directory containing the .in file.
   C DIR  Create, if necessary, and switch to a subdirectory named DIR under
          the main directory for this test.  If DIR is missing, changes
          back to the default directory.  This command is principally
          intended to let you set up remote repositories.
   T N    Set the timeout for versio commands in the rest of this test to N
          seconds.
   + NAME F
          Copy the contents of src/F into a file named NAME.
   - NAME
          Delete the file named NAME.
   > COMMAND OPERANDS
   LINE1
   LINE2
   ...
   <<<
          Run staff-versio with COMMAND ARGUMENTS as its parameters.  Compare
          its output with LINE1, LINE2, etc., reporting an error if there is
          "sufficient" discrepency.  The <<< delimiter may be followed by
          an asterisk (*), in which case, the preceding lines are treated as
          Python regular expressions and matched accordingly.
   = NAME F
          Check that the file named NAME is identical to src/F, and report an
          error if not.
   * NAME
          Check that the file NAME does not exist, and report an error if it
          does.
   E NAME
          Check that file or directory NAME exists, and report an error if it
          does not.
   D VAR "VALUE"
          Defines the variable VAR to have the literal value VALUE.  VALUE is
          taken to be a raw Python string (as in r"VALUE").  Substitutions are
          first applied to VALUE.

For each TEST.in, reports at most one error.  Without the --show option,
simply indicates tests passed and failed.  If N is postive, also prints details
of the first N failing tests. With --show=all, shows details of all failing
tests.  With --keep, keeps the directories created for the tests (with names
TEST.dir).

When finished, reports number of tests passed and failed, and the number of
faulty TEST.in files."""


DIRECTORY_LAYOUT_ERROR = """\
Your {} folder is not where we expected it. Please ensure that your directory
structure matches the following:

sp21-s***
  ├── library-sp21
  │    └── ...
  ├── proj2
  │   ├── versio
  │   ├── testing <==== This should be your CWD
  │   │    ├── runner.py
  │   │    └── ...
  │   └── ...
  └── ...

Note your CWD must be `sp21-s***/proj2/testing`

Also check that your REPO_DIR environment variable is the path to your
`sp21-s***` directory. You can check this by running the command:

    $ echo REPO_DIR
    /Users/omarkhan902/cs61b/61b_sp21_stuff/sp21-s3

That's what mine looks like. Go back to lab1 if you are still having issues"""

JAVA_COMMAND = "java"
STAFF_COMMAND = "staff-versio"
JAVAC_COMMAND = "javac -d ."
JVM_COMMAND = "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005"
TIMEOUT = 10
DEBUG = False
DEBUG_MSG = \
    """
   ============================================================================
  |                   ~~~~~  You are in debug mode  ~~~~~                      |
  |   In this mode, you will be shown each command from the test case.         |
  |                                                                            |
  |   There are three commands:                                                |
  |                                                                            |
  |   1. 'n' - type in 'n' to go to the next command without debugging the     |
  |            current one (analogous to "Step Over" in IntelliJ).             |
  |                                                                            |
  |   2. 's' - type in 's' to debug the current command (analogous to          |
  |            "Step Into" in IntelliJ). Make sure to set breakpoints!         |
  |                                                                            |
  |   3. 'q' - type in 'q' to quit and stop debugging. If you had the `--keep` |
  |            flag, then your directory state will be saved and you can       |
  |            investigate it.                                                 |
   ============================================================================
"""

def Usage():
    print(SHORT_USAGE, file=sys.stderr)
    sys.exit(1)

Mat = None
def Match(patn, s):
    global Mat
    Mat = re.match(patn, s)
    return Mat

def Group(n):
    return Mat.group(n)

def contents(filename):
    try:
        with open(filename) as inp:
            return inp.read()
    except FileNotFoundError:
        return None

def editDistance(s1, s2):
    dist = [list(range(len(s2) + 1))] + \
           [ [i] + [ 0 ] * len(s2) for i in range(1, len(s1) + 1) ]
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            dist[i][j] = min(dist[i-1][j] + 1,
                             dist[i][j-1] + 1,
                             dist[i-1][j-1] + (s1[i-1] != s2[j-1]))
    return dist[len(s1)][len(s2)]

def nextCommand(full_cmnd, timeout):
    return check_output(full_cmnd, shell=True, universal_newlines=True,
                        stdin=DEVNULL, stderr=STDOUT, timeout=timeout)
def stepIntoCommand(full_cmnd):
    out = check_output(full_cmnd, shell=True, universal_newlines=True,
                       stdin=DEVNULL, stderr=STDOUT, timeout=None)
    return out.split("\n", 1)[1]

def createTempDir(base):
    for n in range(100):
        name = "{}_{}".format(base, n)
        try:
            mkdir(name)
            return name
        except OSError:
            pass
    else:
        raise ValueError("could not create temp directory for {}".format(base))

def cleanTempDir(dir):
    rmtree(dir, ignore_errors=True)

def doDelete(name, dir):
    try:
        remove(join(dir, name))
    except OSError:
        pass

def doCopy(dest, src, dir):
    try:
        doDelete(dest, dir)
        copyfile(join(src_dir, src), join(dir, dest))
    except OSError:
        raise ValueError("file {} could not be copied to {}".format(src, dest))

def doCompile(target):
    out = ""
    try:
        full_cmnd = "{} {}".format(JAVAC_COMMAND, target)
        out = check_output(full_cmnd, shell=True, universal_newlines=True,
                           stdin=DEVNULL, stderr=STDOUT)
        return "OK", out
    except CalledProcessError as excp:
        return ("javac exited with code {}".format(excp.args[0]),
                excp.output)

def doExecute(cmnd, dir, timeout):
    here = getcwd()
    out = ""
    try:
        chdir(dir)
        full_cmnd = "{} {}".format(STAFF_COMMAND, cmnd)

        out = nextCommand(full_cmnd, timeout)

        if superverbose:
            print(out)

        return "OK", out
    except CalledProcessError as excp:
        return ("java versio.Main exited with code {}".format(excp.args[0]),
                excp.output)
    except TimeoutExpired:
        return "timeout", None
    finally:
        chdir(here)

def canonicalize(s):
    if s is None:
        return None
    return re.sub('\r', '', s)

def fileExists(f, dir):
    return exists(join(dir, f))

def correctFileOutput(name, expected, dir):
    userData = canonicalize(contents(join(dir, name)))
    stdData = canonicalize(contents(join(src_dir, expected)))
    return userData == stdData

def correctProgramOutput(expected, actual, last_groups, is_regexp):
    expected = re.sub(r'[ \t]+\n', '\n', '\n'.join(expected))
    expected = re.sub(r'(?m)^[ \t]+', ' ', expected)
    actual = re.sub(r'[ \t]+\n', '\n', actual)
    actual = re.sub(r'(?m)^[ \t]+', ' ', actual)

    last_groups[:] = (actual,)
    if is_regexp:
        try:
            if not Match(expected.rstrip() + r"\Z", actual) \
                    and not Match(expected.rstrip() + r"\Z", actual.rstrip()):
                return False
        except:
            raise ValueError("bad pattern")
        last_groups[:] += Mat.groups()
    elif editDistance(expected.rstrip(), actual.rstrip()) > output_tolerance:
        return False
    return True

def reportDetails(test, included_files, line_num):
    if show is None:
        return
    if show <= 0:
        print("   Limit on error details exceeded.")
        return
    direct = dirname(test)

    print("    Error on line {} of {}".format(line_num, basename(test)))

    for base in [basename(test)] + included_files:
        full = join(dirname(test), base)
        print(("-" * 20 + " {} " + "-" * 20).format(base))
        text_lines = list(enumerate(re.split(r'\n\r?', contents(full))))[:-1]
        fmt = "{{:{}d}}. {{}}".format(round(log(len(text_lines), 10)))
        text = '\n'.join(map(lambda p: fmt.format(p[0] + 1, p[1]), text_lines))
        print(text)
        print("-" * (42 + len(base)))

def chop_nl(s):
    if s and s[-1] == '\n':
        return s[:-1]
    else:
        return s

def line_reader(f, prefix):
    n = 0
    try:
        with open(f) as inp:
            while True:
                L = inp.readline()
                if L == '':
                    return
                n += 1
                included_file = yield (prefix + str(n), L)
                if included_file:
                    yield None
                    yield from line_reader(included_file, prefix + str(n) + ".")
    except FileNotFoundError:
        raise ValueError("file {} not found".format(f))

def doTest(test):
    last_groups = []
    base = splitext(basename(test))[0]
    print("{}:".format(base), end=" \n")
    cdir = tmpdir = createTempDir(base)
    if verbose:
        print("Testing directory: {}".format(tmpdir))
    timeout = TIMEOUT
    defns = {}

    def do_substs(L):
        c = 0
        L0 = None
        while L0 != L and c < 10:
            c += 1
            L0 = L
            L = re.sub(r'\$\{(.*?)\}', subst_var, L)
        return L

    def subst_var(M):
        key = M.group(1)
        if Match(r'\d+$', key):
            try:
                return last_groups[int(key)]
            except IndexError:
                raise ValueError("FAILED (nonexistent group: {{{}}})"
                                 .format(key))
        elif M.group(1) in defns:
            return defns[M.group(1)]
        else:
            raise ValueError("undefined substitution: ${{{}}}".format(M.group(1)))

    try:
        line_num = None
        inp = line_reader(test, '')
        included_files = []
        while True:
            line_num, line = next(inp, (line_num, ''))
            if line == "":
                print("OK")
                return True
            if not Match(r'\s*#', line):
                line = do_substs(line)
            if verbose:
                print("+ {}".format(line.rstrip()))
            if Match(r'\s*#', line) or Match(r'\s+$', line):
                pass
            elif Match(r'I\s+(\S+)', line):
                inp.send(join(dirname(test), Group(1)))
                included_files.append(Group(1))
            elif Match(r'C\s*(\S*)', line):
                if Group(1) == "":
                    cdir = tmpdir
                else:
                    cdir = join(tmpdir, Group(1))
                    if not exists(cdir):
                        mkdir(cdir)
            elif Match(r'T\s*(\S+)', line):
                try:
                    timeout = float(Group(1))
                except:
                    ValueError("bad time: {}".format(line))
            elif Match(r'\+\s*(\S+)\s+(\S+)', line):
                doCopy(Group(1), Group(2), cdir)
            elif Match(r'-\s*(\S+)', line):
                doDelete(Group(1), cdir)
            elif Match(r'>\s*(.*)', line):
                cmnd = Group(1)
                expected = []
                while True:
                    line_num, L = next(inp, (line_num, ''))
                    if L == '':
                        raise ValueError("unterminated command: {}"
                                         .format(line))
                    L = L.rstrip()
                    if Match(r'<<<(\*?)', L):
                        is_regexp = Group(1)
                        break
                    expected.append(do_substs(L))
                msg, out = doExecute(cmnd, cdir, timeout)
                if verbose:
                    if out:
                        print(re.sub(r'(?m)^', '- ', chop_nl(out)))
                if msg == "OK":
                    if not correctProgramOutput(expected, out, last_groups,
                                                is_regexp):
                        msg = "incorrect output"
                elif msg == "User Exit":
                    print("Exiting Debug mode ...")
                    break
                if msg != 'OK':
                    print("ERROR ({})".format(msg))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'=\s*(\S+)\s+(\S+)', line):
                if not correctFileOutput(Group(1), Group(2), cdir):
                    print("ERROR (file {} has incorrect content)"
                          .format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'\*\s*(\S+)', line):
                if fileExists(Group(1), cdir):
                    print("ERROR (file {} present)".format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'E\s*(\S+)', line):
                if not fileExists(Group(1), cdir):
                    print("ERROR (file or directory {} not present)"
                          .format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'(?s)D\s*([a-zA-Z_][a-zA-Z_0-9]*)\s*"(.*)"\s*$', line):
                defns[Group(1)] = Group(2)
            else:
                raise ValueError("bad test line at {}".format(line_num))
    finally:
        if not keep:
            cleanTempDir(tmpdir)
        else:
            print(f"\nDirectory state saved in {tmpdir}")

if __name__ == "__main__":
    show = None
    keep = False
    lib_dir = None
    verbose = False
    superverbose = False
    src_dir = 'src'
    gitlet_dir = join(dirname(abspath(getcwd())), "versio")
    output_tolerance = 0

    try:
        opts, files = \
            getopt(sys.argv[1:], '',
                   ['show=', 'keep', 'lib=', 'verbose', 'src=',
                    'tolerance=', 'superverbose', 'debug'])
        for opt, val in opts:
            if opt == '--show':
                show = int(val)
            elif opt == "--keep":
                keep = True
            elif opt == "--lib":
                lib_dir = val
            elif opt == "--src":
                src_dir = val
            elif opt == "--verbose":
                verbose = True
            elif opt == "--tolerance":
                output_tolerance = int(val)
            elif opt == "--superverbose":
                superverbose = True
            elif opt == "--debug":
                DEBUG = True
                TIMEOUT = 100000
    except GetoptError:
        Usage()
    if not files:
        print(USAGE)
        sys.exit(0)

    matching_files = []
    for path in files:
        matching_files += glob(path)
    files = matching_files

    num_tests = len(files)
    errs = 0
    fails = 0

    print(DEBUG_MSG)

    for test in files:
        try:
            if not exists(test):
                num_tests -= 1
            elif not doTest(test):
                errs += 1
                if type(show) is int:
                    show -= 1
        except ValueError as excp:
            print("FAILED ({})".format(excp.args[0]))
            fails += 1

    cleanTempDir(join(abspath(getcwd()), "versio"))

    print()
    print("Ran {} tests. ".format(num_tests), end="")
    if errs == fails == 0:
        print("All passed.")
    else:
        print("{} passed.".format(num_tests - errs - fails))
        sys.exit(1)

================
File: testing/student_tests/definitions.inc
================
# Standard definitions
D DATE "Date: \w\w\w \w\w\w \d+ \d\d:\d\d:\d\d \d\d\d\d [-+]\d\d\d\d"
# A status log header RE.  Captures the commit id in its sole group.
D COMMIT_HEAD "commit ([a-f0-9]+)[ \t]*\n(?:Merge:\s+[0-9a-f]{7}\s+[0-9a-f]{7}[ ]*\n)?${DATE}"
# A full log entry.  Captures the entry. Assume logs messages don't contain
# "==="
D COMMIT_LOG "(===[ ]*\ncommit [a-f0-9]+[ ]*\n(?:Merge:\s+[0-9a-f]{7}\s+[0-9a-f]{7}[ ]*\n)?${DATE}[ ]*\n(?:.|\n)*?(?=\Z|\n===))"
# An arbitrary line of text (works even with ?s)
D ARBLINE "[^\n]*(?=\n|\Z)"
# Zero or more arbitrary full lines of text.
D ARBLINES "(?:(?:.|\n)*(?:\n|\Z)|\A|\Z)"

================
File: testing/tester.py
================
import sys, re
from subprocess import \
     check_output, PIPE, STDOUT, DEVNULL, CalledProcessError, TimeoutExpired
from os.path import abspath, basename, dirname, exists, join, splitext
from getopt import getopt, GetoptError
from os import chdir, environ, getcwd, mkdir, remove, access, W_OK
from shutil import copyfile, rmtree
from math import log

SHORT_USAGE = """\
Usage: python3 tester.py OPTIONS TEST.in ...

   OPTIONS may include
       --show=N       Show details on up to N tests.
       --show=all     Show details on all tests.
       --keep         Keep test directories
       --progdir=DIR  Directory or JAR files containing versio application
       --timeout=SEC  Default number of seconds allowed to each execution
                      of versio.
       --src=SRC      Use SRC instead of "src" as the subdirectory containing
                      files referenced by + and =.
       --debug        Allows you to step through commands one by one and
                      attach a remote debugger
       --tolerance=N  Set the maximum allowed edit distance between program
                      output and expected output to N (default 3).
       --verbose      Print extra information about execution.
"""

USAGE = SHORT_USAGE + """\

For each TEST.in, change to an empty directory, and execute the instructions
in TEST.in.  Before executing an instruction, first replace any occurrence
of ${VAR} with the current definition of VAR (see the D command below).
Replace any occurrence of ${N} for non-negative decimal numeral N with
the value of the Nth captured group in the last ">" command's expected
output lines.  Undefined if the last ">" command did not end in "<<<*",
or did not have the indicated group. N=0 indicates the entire matched string.

The instructions each have one of the following forms:

   # ...  A comment, producing no effect.
   I FILE Include.  Replace this statement with the contents of FILE,
          interpreted relative to the directory containing the .in file.
   C DIR  Create, if necessary, and switch to a subdirectory named DIR under
          the main directory for this test.  If DIR is missing, changes
          back to the default directory.  This command is principally
          intended to let you set up remote repositories.
   T N    Set the timeout for versio commands in the rest of this test to N
          seconds.
   + NAME F
          Copy the contents of src/F into a file named NAME.
   - NAME
          Delete the file named NAME.
   > COMMAND OPERANDS
   LINE1
   LINE2
   ...
   <<<
          Run versio.Main with COMMAND ARGUMENTS as its parameters.  Compare
          its output with LINE1, LINE2, etc., reporting an error if there is
          "sufficient" discrepency.  The <<< delimiter may be followed by
          an asterisk (*), in which case, the preceding lines are treated as 
          Python regular expressions and matched accordingly. The directory
          or JAR file containing the versio.Main program is assumed to be
          in directory DIR specifed by --progdir (default is ..).
   = NAME F
          Check that the file named NAME is identical to src/F, and report an
          error if not.
   * NAME
          Check that the file NAME does not exist, and report an error if it
          does.
   E NAME
          Check that file or directory NAME exists, and report an error if it
          does not.
   D VAR "VALUE"
          Defines the variable VAR to have the literal value VALUE.  VALUE is
          taken to be a raw Python string (as in r"VALUE").  Substitutions are
          first applied to VALUE.

For each TEST.in, reports at most one error.  Without the --show option,
simply indicates tests passed and failed.  If N is postive, also prints details
of the first N failing tests. With --show=all, shows details of all failing
tests.  With --keep, keeps the directories created for the tests (with names
TEST.dir).

When finished, reports number of tests passed and failed, and the number of
faulty TEST.in files."""

TIMEOUT = 10

JAVA_COMMAND = "java -ea"
GITLET_CLASS = "versio.Main"
JVM_OPTIONS = "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005"

DEBUG = False
DEBUG_MSG = \
    """You are in debug mode.
    In this mode, you will be shown each command from the test case.
    If you would like to step into and debug the command, type 's'. Once you have done so, go back to IntelliJ and click the debug button.
    If you would like to move on to the next command, type 'n'."""

def Usage():
    print(SHORT_USAGE, file=sys.stderr)
    sys.exit(1)

Mat = None
def Match(patn, s):
    global Mat
    Mat = re.match(patn, s)
    return Mat

def Group(n):
    return Mat.group(n)

def contents(filename):
    try:
        with open(filename) as inp:
            return inp.read()
    except FileNotFoundError:
        return None

def editDistance(s1, s2):
    dist = [list(range(len(s2) + 1))] + \
           [ [i] + [ 0 ] * len(s2) for i in range(1, len(s1) + 1) ]
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            dist[i][j] = min(dist[i-1][j] + 1,
                             dist[i][j-1] + 1,
                             dist[i-1][j-1] + (s1[i-1] != s2[j-1]))
    return dist[len(s1)][len(s2)]

def createTempDir(base):
    for n in range(100):
        name = "{}_{}".format(base, n)
        try:
            mkdir(name)
            return name
        except OSError:
            pass
    else:
        raise ValueError("could not create temp directory for {}".format(base))

def cleanTempDir(dir):
    rmtree(dir, ignore_errors=True)

def doDelete(name, dir):
    try:
        remove(join(dir, name))
    except OSError:
        pass

def doCopy(dest, src, dir):
    try:
        doDelete(dest, dir)
        copyfile(join(src_dir, src), join(dir, dest))
    except OSError:
        raise ValueError("file {} could not be copied to {}".format(src, dest))

def doExecute(cmnd, dir, timeout, line_num):
    here = getcwd()
    out = ""
    try:
        chdir(dir)
        full_cmnd = "{} {} {}".format(JAVA_COMMAND, GITLET_CLASS, cmnd)
        skip_first_line = False

        if DEBUG:
            print("[line {}]: versio {}".format(line_num, cmnd))
            input_prompt = ">>> "
            next_cmd = input(input_prompt)
            while(next_cmd not in "ns"):
                print("Please enter either 'n' or 's'.")
                next_cmd = input(input_prompt)

            if next_cmd == "s":
                full_cmnd = "{} {} {} {}".format(JAVA_COMMAND, JVM_OPTIONS, GITLET_CLASS, cmnd)
                timeout, skip_first_line = None, True

        out = doCommand(full_cmnd, timeout, skip_first_line)
        return "OK", out
    except CalledProcessError as excp:
        return ("java versio.Main exited with code {}".format(excp.args[0]),
                excp.output)
    except TimeoutExpired:
        return "timeout", None
    finally:
        chdir(here)

def doCommand(full_cmnd, timeout, skip_first_line=False):
    out = check_output(full_cmnd, shell=True, universal_newlines=True,
                        stdin=DEVNULL, stderr=STDOUT, timeout=timeout)
    if skip_first_line:
        out = out.split("\n", 1)[1]

    return out

def canonicalize(s):
    if s is None:
        return None
    return re.sub('\r', '', s)

def fileExists(f, dir):
    return exists(join(dir, f))

def correctFileOutput(name, expected, dir):
    userData = canonicalize(contents(join(dir, name)))
    stdData = canonicalize(contents(join(src_dir, expected)))
    return userData == stdData

def correctProgramOutput(expected, actual, last_groups, is_regexp):
    expected = re.sub(r'[ \t]+\n', '\n', '\n'.join(expected))
    expected = re.sub(r'(?m)^[ \t]+', ' ', expected)
    actual = re.sub(r'[ \t]+\n', '\n', actual)
    actual = re.sub(r'(?m)^[ \t]+', ' ', actual)

    last_groups[:] = (actual,)
    if is_regexp:
        try:
            if not Match(expected.rstrip() + r"\Z", actual) \
                   and not Match(expected.rstrip() + r"\Z", actual.rstrip()):
                return False
        except:
            raise ValueError("bad pattern")
        last_groups[:] += Mat.groups()
    elif editDistance(expected.rstrip(), actual.rstrip()) > output_tolerance:
        return False
    return True

def reportDetails(test, included_files, line_num):
    if show is None:
        return
    if show <= 0:
        print("   Limit on error details exceeded.")
        return
    direct = dirname(test)

    print("    Error on line {} of {}".format(line_num, basename(test)))

    for base in [basename(test)] + included_files:
        full = join(dirname(test), base)
        print(("-" * 20 + " {} " + "-" * 20).format(base))
        text_lines = list(enumerate(re.split(r'\n\r?', contents(full))))[:-1]
        fmt = "{{:{}d}}. {{}}".format(round(log(len(text_lines), 10)))
        text = '\n'.join(map(lambda p: fmt.format(p[0] + 1, p[1]), text_lines))
        print(text)
        print("-" * (42 + len(base)))

def chop_nl(s):
    if s and s[-1] == '\n':
        return s[:-1]
    else:
        return s

def line_reader(f, prefix):
    n = 0
    try:
        with open(f) as inp:
            while True:
                L = inp.readline()
                if L == '':
                    return
                n += 1
                included_file = yield (prefix + str(n), L)
                if included_file:
                    yield None
                    yield from line_reader(included_file, prefix + str(n) + ".")
    except FileNotFoundError:
        raise ValueError("file {} not found".format(f))

def doTest(test):
    last_groups = []
    base = splitext(basename(test))[0]
    print("{}:".format(base))
    cdir = tmpdir = createTempDir(base)

    if verbose:
        print("Testing directory: {}".format(tmpdir))

    if DEBUG:
        print(DEBUG_MSG)

    timeout = TIMEOUT
    defns = {}

    def do_substs(L):
        c = 0
        L0 = None
        while L0 != L and c < 10:
            c += 1
            L0 = L
            L = re.sub(r'\$\{(.*?)\}', subst_var, L)
        return L

    def subst_var(M):
        key = M.group(1)
        if Match(r'\d+$', key):
            try:
                return last_groups[int(key)]
            except IndexError:
                raise ValueError("FAILED (nonexistent group: {{{}}})"
                                 .format(key))
        elif M.group(1) in defns:
            return defns[M.group(1)]
        else:
            raise ValueError("undefined substitution: ${{{}}}".format(M.group(1)))

    try:
        line_num = None
        inp = line_reader(test, '')
        included_files = []
        while True:
            line_num, line = next(inp, (line_num, ''))
            if line == "":
                print("OK")
                return True
            if not Match(r'\s*#', line):
                line = do_substs(line)
            if verbose:
                print("+ {}".format(line.rstrip()))
            if Match(r'\s*#', line) or Match(r'\s+$', line):
                pass
            elif Match(r'I\s+(\S+)', line):
                inp.send(join(dirname(test), Group(1)))
                included_files.append(Group(1))
            elif Match(r'C\s*(\S*)', line):
                if Group(1) == "":
                    cdir = tmpdir
                else:
                    cdir = join(tmpdir, Group(1))
                    if not exists(cdir):
                        mkdir(cdir)
            elif Match(r'T\s*(\S+)', line):
                try:
                    timeout = float(Group(1))
                except:
                    ValueError("bad time: {}".format(line))
            elif Match(r'\+\s*(\S+)\s+(\S+)', line):
                doCopy(Group(1), Group(2), cdir)
            elif Match(r'-\s*(\S+)', line):
                doDelete(Group(1), cdir)
            elif Match(r'>\s*(.*)', line):
                cmnd = Group(1)
                expected = []
                while True:
                    line_num, L = next(inp, (line_num, ''))
                    if L == '':
                        raise ValueError("unterminated command: {}"
                                         .format(line))
                    L = L.rstrip()
                    if Match(r'<<<(\*?)', L):
                        is_regexp = Group(1)
                        break
                    expected.append(do_substs(L))
                msg, out = doExecute(cmnd, cdir, timeout, line_num)
                if verbose:
                    if out:
                        print(re.sub(r'(?m)^', '- ', chop_nl(out)))
                if msg == "OK":
                    if not correctProgramOutput(expected, out, last_groups,
                                                is_regexp):
                        msg = "incorrect output"
                if msg != "OK":
                    print("ERROR ({})".format(msg))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'=\s*(\S+)\s+(\S+)', line):
                if not correctFileOutput(Group(1), Group(2), cdir):
                    print("ERROR (file {} has incorrect content)"
                          .format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'\*\s*(\S+)', line):
                if fileExists(Group(1), cdir):
                    print("ERROR (file {} present)".format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'E\s*(\S+)', line):
                if not fileExists(Group(1), cdir):
                    print("ERROR (file or directory {} not present)"
                          .format(Group(1)))
                    reportDetails(test, included_files, line_num)
                    return False
            elif Match(r'(?s)D\s*([a-zA-Z_][a-zA-Z_0-9]*)\s*"(.*)"\s*$', line):
                defns[Group(1)] = Group(2)
            else:
                raise ValueError("bad test line at {}".format(line_num))
    finally:
        if not keep:
            cleanTempDir(tmpdir)

if __name__ == "__main__":
    show = None
    keep = False
    prog_dir = None
    verbose = False
    src_dir = 'src'
    output_tolerance = 3

    try:
        opts, files = \
            getopt(sys.argv[1:], '',
                   ['show=', 'keep', 'progdir=', 'verbose', 'src=',
                    'tolerance=', 'debug'])
        for opt, val in opts:
            if opt == '--show':
                val = val.lower()
                if re.match(r'-?\d+', val):
                    show = int(val)
                elif val == 'all':
                    show = val
                else:
                    Usage()
            elif opt == "--keep":
                keep = True
            elif opt == "--progdir":
                prog_dir = val
            elif opt == "--src":
                src_dir = abspath(val)
            elif opt == "--verbose":
                verbose = True
            elif opt == "--tolerance":
                output_tolerance = int(val)
            elif opt == "--debug":
                DEBUG = True
        if prog_dir is None:
            prog_dir = abspath(getcwd())
            k = 10
            while k > 0 and access(prog_dir, W_OK):
                k -= 1
                if exists(join(prog_dir, 'versio', 'Main.class')):
                    break
                prog_dir = dirname(prog_dir)
            else:
                print("Could not find versio.Main.", file=sys.stderr)
                sys.exit(1)
    except GetoptError:
        Usage()
    if not files:
        print(USAGE)
        sys.exit(0)

    ON_WINDOWS = Match(r'.*\\', join('a', 'b'))
    if ON_WINDOWS:
        if 'CLASSPATH' in environ:
            environ['CLASSPATH'] = "{};{}".format(prog_dir, environ['CLASSPATH'])
        else:
            environ['CLASSPATH'] = "{}".format(prog_dir)
    else:
        if 'CLASSPATH' in environ:
            environ['CLASSPATH'] = "{}:{}".format(prog_dir, environ['CLASSPATH'])
        else:
            environ['CLASSPATH'] = "{}".format(prog_dir)
        JAVA_COMMAND = 'exec ' + JAVA_COMMAND

    num_tests = len(files)
    errs = 0
    fails = 0

    for test in files:
        try:
            if not exists(test):
                num_tests -= 1
            elif not doTest(test):
                errs += 1
                if type(show) is int:
                    show -= 1
        except ValueError as excp:
            print("FAILED ({})".format(excp.args[0]))
            fails += 1

    print()
    print("Ran {} tests. ".format(num_tests), end="")
    if errs == fails == 0:
        print("All passed.")
    else:
        print("{} passed.".format(num_tests - errs - fails))
        sys.exit(1)

================
File: testing/wug.txt
================
wug...

================
File: wug.txt
================
in Merge branch 2add
